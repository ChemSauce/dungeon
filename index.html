<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler - Town</title>
    <script src="https://cdn.tailwindcss.com"></script>
	<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .bg-forest {
            background-image: url('images/forgottenforrest.png');
            background-size: cover;
            background-position: center;
        }
        .bg-swamp {
            background-image: url('path/to/your/swamp-texture.png');
            background-size: cover;
            background-position: center;
        }
        .bg-plains {
            background-image: url('path/to/your/plains-texture.png');
            background-size: cover;
            background-position: center;
        }
        .bg-peak {
            background-image: url('path/to/your/peak-texture.png');
            background-size: cover;
            background-position: center;
        }
        .bg-wasteland {
            background-image: url('forgottenforrest.png');
            background-size: cover;
            background-position: center;
        }
        .class-card, .town-action-card, .slot, .ability-button {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .class-card:hover, .town-action-card:hover, .slot:hover, .ability-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .slot {
            min-height: 64px; /* 4rem */
            min-width: 64px; /* 4rem */
            border: 2px solid transparent;
            cursor: pointer;
            position: relative; /* Needed for quantity display */
        }
        #tooltip {
            pointer-events: none;
        }
        .health-bar-bg { background-color: #4a5568; }
        .health-bar-fill { background-color: #e53e3e; transition: width 0.5s ease-in-out; }
        .mana-bar-fill { background-color: #3182ce; transition: width 0.5s ease-in-out; }
        .reputation-bar-fill { background-color: #d69e2e; transition: width 0.5s ease-in-out; } /* yellow-600 */
        .border-normal { border-color: #4a5568; } /* gray-600 */
        .border-common { border-color: #38a169; } /* green-600 */
        .border-rare { border-color: #3182ce; } /* blue-600 */
        .border-epic { border-color: #805ad5; } /* purple-600 */
        .border-legendary { border-color: #dd6b20; } /* orange-600 */
        .border-elite { border-color: #e53e3e; } /* red-600 */
        .quest-title-bg {
            background-image: url('image\quest-title-bg.png');
            background-size: cover;
            background-position: center;
            /* This adds a shadow to the text to make it readable over the image */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">

    <div id="tooltip" class="hidden absolute bg-gray-900 border border-gray-600 rounded-lg p-2 text-sm z-50 shadow-lg"></div>

    <div id="game-container" class="w-full max-w-6xl mx-auto p-6 md:p-8 bg-gray-800 rounded-2xl shadow-2xl">

        <div id="dialogue-modal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-40">
            <div class="bg-gray-800 rounded-2xl shadow-2xl p-6 w-full max-w-lg border-2 border-gray-600 flex gap-6">
                <div class="flex-shrink-0">
                    <img id="dialogue-npc-image" src="" alt="NPC Portrait" class="w-32 h-32 object-contain rounded-lg border-4 border-gray-600 bg-gray-900">
                </div>
                <div class="flex-grow flex flex-col">
                    <h2 id="dialogue-npc-name" class="text-2xl font-bold text-yellow-400">NPC Name</h2>
                    <p id="dialogue-npc-text" class="text-gray-300 mt-2 flex-grow">Dialogue text goes here...</p>
                    <div id="dialogue-actions" class="mt-4 flex gap-4 justify-end">
                        <button id="dialogue-close-btn" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Leave</button>
                    </div>
                </div>
            </div>
        </div>
		
		<div id="guide-modal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
			<div class="bg-gray-800 rounded-2xl shadow-2xl p-6 w-full max-w-lg border-2 border-yellow-400 flex gap-6">
				<div class="flex-shrink-0">
					<img id="guide-npc-image" src="" alt="Guide Portrait" class="w-32 h-32 object-contain rounded-lg border-4 border-gray-600 bg-gray-900">
				</div>
				<div class="flex-grow flex flex-col">
					<h2 id="guide-npc-name" class="text-2xl font-bold text-yellow-400">Guide</h2>
					<p id="guide-npc-text" class="text-gray-300 mt-2 flex-grow">Guide dialogue text goes here...</p>
					<div class="mt-4 flex gap-4 justify-end">
						<button id="guide-close-btn" class="bg-yellow-600 hover:bg-yellow-700 font-bold py-2 px-4 rounded-lg">Continue</button>
					</div>
				</div>
			</div>
		</div>	
		<div id="alpha-gate-screen">
			<h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-yellow-400">Dungeon Crawler Alpha</h1>
			<p class="text-center text-gray-400 mb-8">Please enter the invite code to continue.</p>
			<div class="max-w-md mx-auto bg-gray-700 p-8 rounded-xl">
				<div class="mb-4">
					<label for="alpha-code" class="block text-sm font-bold mb-2">Invite Code</label>
					<input type="password" id="alpha-code" class="w-full p-2 rounded bg-gray-800 border border-gray-600 focus:outline-none focus:border-yellow-500">
				</div>
				<button id="alpha-submit-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg w-full">Enter</button>
			</div>
		</div>
        <div id="auth-screen", class="hidden">
			<h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-yellow-400">Dungeon Crawler</h1>
			<p class="text-center text-gray-400 mb-8">Login or create an account to begin your adventure.</p>
			<div class="max-w-md mx-auto bg-gray-700 p-8 rounded-xl">
				<div class="mb-4">
					<label for="email" class="block text-sm font-bold mb-2">Email</label>
					<input type="email" id="email" class="w-full p-2 rounded bg-gray-800 border border-gray-600 focus:outline-none focus:border-yellow-500">
				</div>
				<div class="mb-6">
					<label for="password" class="block text-sm font-bold mb-2">Password</label>
					<input type="password" id="password" class="w-full p-2 rounded bg-gray-800 border border-gray-600 focus:outline-none focus:border-yellow-500">
				</div>
				<div class="flex items-center justify-between gap-4">
					<button id="login-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg w-full">Login</button>
					<button id="signup-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg w-full">Sign Up</button>
				</div>
			</div>
		</div>
		
        <div id="character-selection-screen">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-yellow-400">Choose Your Hero</h1>
            <p class="text-center text-gray-400 mb-8">Your legend begins now. Select a class to start your journey.</p>
            <div id="class-selection-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"></div>
        </div>

        <div id="town-screen" class="hidden">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl md:text-4xl font-bold text-yellow-400">Welcome to Town</h1>
                <div class="flex gap-2">
                    <button id="save-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Save</button>
                    <button id="main-menu-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Main Menu</button>
                </div>
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div class="lg:col-span-2 bg-gray-700 p-6 rounded-xl">
                    <div class="flex flex-col md:flex-row gap-6">
                        <div class="flex-shrink-0 mx-auto md:mx-0">
                            <img id="player-image" src="" alt="Character Portrait" class="w-40 h-40 object-contain rounded-lg border-4 border-gray-600 bg-gray-900" onerror="this.onerror=null;this.src='https://placehold.co/160x160/1f2937/ffffff?text=Hero';">
                        </div>
                        <div class="flex-grow">
                            <div>
                                <h3 id="player-name" class="text-2xl font-semibold"></h3>
                                <div class="flex justify-between items-center">
                                    <p class="text-gray-400">Level <span id="player-level">1</span></p>
                                    <p class="text-yellow-400 font-bold">Gold: <span id="player-gold">0</span></p>
                                </div>
                                 <div class="w-full health-bar-bg rounded-full h-3 mt-1 border border-gray-600">
                                     <div id="player-xp-bar" class="bg-yellow-400 h-full rounded-full" style="width: 0%;"></div>
                                </div>
                              <p class="text-xs text-center mt-1">XP: <span id="player-xp">0</span> / <span id="player-xp-needed">100</span></p>
                             </div>
                             <!-- Health and Mana Bars -->
                            <div class="w-full health-bar-bg rounded-full h-4 mt-4 border-2 border-gray-600">
                                <div id="town-player-health-bar" class="health-bar-fill h-full rounded-full"></div>
                            </div>
                            <p class="text-xs text-center mt-1">HP: <span id="town-player-hp">0</span> / <span id="town-player-max-hp">0</span></p>
                            <div class="w-full health-bar-bg rounded-full h-4 mt-2 border-2 border-gray-600">
                                <div id="town-player-mana-bar" class="mana-bar-fill h-full rounded-full"></div>
                            </div>
                            <p class="text-xs text-center mt-1">Mana: <span id="town-player-mana">0</span> / <span id="town-player-max-mana">0</span></p>
                          <div id="player-stats" class="grid grid-cols-3 gap-4 mt-4"></div>
                        </div>
                    </div>
                     <div class="mt-4">
                         <h4 class="text-lg font-semibold mb-2 text-yellow-500">Abilities</h4>
                         <div id="player-abilities-list" class="space-y-2"></div>
                    </div>
                </div>
                <div class="bg-gray-700 p-6 rounded-xl">
                    <h3 class="text-xl font-semibold mb-4 text-center">Equipment</h3>
                    <div class="grid grid-cols-3 gap-4 justify-items-center">
                        <div></div>
                        <div id="slot-head" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Head</div>
                        <div></div>

                        <div id="slot-weapon" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Weapon</div>
                        <div id="slot-chest" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Chest</div>
                        <div id="slot-gloves" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Gloves</div>
                        <div id="slot-offhand" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Off-Hand</div>
                        <div id="slot-legs" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Legs</div>
                        <div id="slot-special" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Special</div>
                        <div></div>
                        <div id="slot-boots" class="slot bg-gray-900 rounded-md flex items-center justify-center text-gray-500 text-xs text-center p-1">Boots</div>
                    </div>
                </div>
            </div>
            <div class="mt-8 bg-gray-700 p-6 rounded-xl">
                <h3 class="text-xl font-semibold mb-4">Inventory</h3>
                <div id="inventory-slots" class="grid grid-cols-5 gap-4"></div>
            </div>
            <div id="town-actions" class="mt-8 grid grid-cols-1 md:grid-cols-4 gap-6">
                <div id="visit-blacksmithshop" class="town-action-card bg-gray-700 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🔨</div><h3 class="text-xl font-bold">Visit blacksmithshop</h3>
                </div>
                <div id="enter-dungeon" class="town-action-card bg-red-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">💀</div><h3 class="text-xl font-bold">Enter the Dungeon</h3>
                </div>
                <div id="challenge-boss" class="town-action-card bg-purple-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">👑</div><h3 class="text-xl font-bold">Challenge the Boss</h3>
                </div>
                <div id="visit-inn" class="town-action-card bg-green-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🛌</div><h3 class="text-xl font-bold">Visit the Inn</h3>
                </div>
                <div id="visit-professions" class="town-action-card bg-gray-700 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🧑‍🔧</div><h3 class="text-xl font-bold">Professions</h3>
                </div>
				<div id="visit-bank" class="town-action-card bg-gray-700 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🧑‍🔧</div><h3 class="text-xl font-bold">Banker</h3>
                </div>
                <div id="visit-map" class="town-action-card bg-yellow-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🗺️</div><h3 class="text-xl font-bold">World Map</h3>
                </div>
				<div id="view-achievements" class="town-action-card bg-purple-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🏆</div><h3 class="text-xl font-bold">Achievements</h3>
                </div>
            </div>
        </div>

        <div id="inn-screen" class="hidden">
            <div id="inn-main-view">
                <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400">The Weary Adventurer Inn</h1>
                <div class="text-center">
                    <p class="text-lg text-gray-300 mb-6">A warm bed and a hot meal can do wonders for a tired soul.</p>
                    <div class="flex justify-center gap-4">
                        <button id="inn-rest-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-xl">Rest (10g)</button>
                        <button id="inn-reputation-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg text-xl">Reputation</button>
                        <button id="inn-train-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-xl">Train Subclass</button>
                        <button id="inn-quest-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl">Quest Board</button>
                    </div>
                </div>
            </div>
            <div id="inn-reputation-view" class="hidden">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                    <div class="md:col-span-1 bg-gray-700 p-6 rounded-xl flex flex-col items-center text-center">
                        <img id="reputation-npc-image" src="" alt="NPC" class="w-32 h-32 object-contain rounded-lg border-4 border-gray-600 bg-gray-900 mb-4">
                        <h2 id="reputation-npc-name" class="text-xl font-bold text-yellow-400"></h2>
                        <p id="reputation-npc-text" class="text-gray-300 mt-2 flex-grow"></p>
                    </div>
                    <div class="md:col-span-2">
                         <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400">Factions</h1>
                         <div id="faction-container" class="space-y-4"></div>
                         <div id="reputation-reward-container" class="text-center mt-4"></div>
                    </div>
                </div>
            </div>
            <div class="text-center mt-8">
                <button id="leave-inn-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Leave Inn</button>
            </div>
        </div>
        
        <div id="subclass-selection-screen" class="hidden">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-yellow-400">Choose Your Specialization</h1>
            <p class="text-center text-gray-400 mb-8">This choice is permanent and will define your path. Cost: 100 Gold.</p>
            <div id="subclass-selection-container" class="grid grid-cols-1 md:grid-cols-3 gap-6"></div>
             <div class="text-center mt-8">
                <button id="return-to-inn-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Back to Inn</button>
            </div>
        </div>

        <div id="quest-board-screen" class="hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div class="md:col-span-1 bg-gray-700 p-6 rounded-xl flex flex-col items-center text-center">
                    <img id="quest-npc-image" src="" alt="NPC" class="w-32 h-32 object-contain rounded-lg border-4 border-gray-600 bg-gray-900 mb-4">
                    <h2 id="quest-npc-name" class="text-xl font-bold text-yellow-400"></h2>
                    <p id="quest-npc-text" class="text-gray-300 mt-2 flex-grow"></p>
                </div>
                <div class="md:col-span-2 bg-slate-800 p-6 rounded-xl">
                    <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400 quest-title-bg rounded-lg py-2">Quest Board</h1>
                    <div class="space-y-8 max-h-[60vh] overflow-y-auto pr-2">
                        <div class="bg-gray-900/50 p-4 rounded-lg">
                            <h2 class="text-2xl font-bold text-yellow-300 mb-4 border-b-2 border-gray-600 pb-2 quest-title-bg rounded-md py-1 px-4">Story Quests</h2>
                            <div id="story-quest-container" class="space-y-4"></div>
                        </div>
                        <div class="bg-gray-900/50 p-4 rounded-lg">
                             <h2 class="text-2xl font-bold text-yellow-300 mb-4 border-b-2 border-gray-600 pb-2 quest-title-bg rounded-md py-1 px-4">Profession Quests</h2>
                            <div id="profession-quest-container" class="space-y-4"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="text-center mt-8">
                <button id="quest-return-to-inn-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Back to Inn</button>
            </div>
        </div>

        <div id="professions-screen" class="hidden">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400">Professions</h1>
            <p class="text-center text-gray-400 mb-8">Choose a profession to view quests and recipes.</p>
            <div id="professions-selection-container" class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl mx-auto">
                <div id="select-blacksmithing" class="town-action-card bg-gray-700 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🔨</div>
                    <h3 class="text-xl font-bold">Blacksmithing</h3>
                    <p class="text-sm text-gray-400 mt-2">Craft weapons and armor from ore and other durable materials.</p>
                </div>
                <div id="select-herbalism" class="town-action-card bg-green-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🧉</div>
                    <h3 class="text-xl font-bold">Herbalism</h3>
                    <p class="text-sm text-gray-400 mt-2">Create potions and elixirs from plants found in the wild.</p>
                </div>
				<div id="select-cooking" class="town-action-card bg-green-900/50 p-6 rounded-xl text-center cursor-pointer">
                    <div class="text-4xl mb-2">🧉</div>
                    <h3 class="text-xl font-bold">Cooking</h3>
                    <p class="text-sm text-gray-400 mt-2">Cook up some food</p>
                </div>
            </div>
            <div class="text-center mt-8">
                <button id="return-to-town-from-professions" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Back to Town</button>
            </div>
        </div>

        <div id="trainer-screen" class="hidden">
            <h1 id="trainer-title" class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400"></h1>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="bg-gray-700 p-6 rounded-xl">
                    <h2 class="text-2xl font-semibold mb-4 border-b-2 border-gray-600 pb-2">Trainer Quests</h2>
                    <div id="trainer-quests" class="space-y-4 max-h-96 overflow-y-auto"></div>
                </div>
                <div class="bg-gray-700 p-6 rounded-xl">
                    <h2 class="text-2xl font-semibold mb-4 border-b-2 border-gray-600 pb-2">Learned Recipes</h2>
                    <div id="trainer-recipes" class="space-y-3 max-h-96 overflow-y-auto"></div>
                </div>
            </div>
            <div class="text-center mt-8">
                <button id="leave-trainer-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Back to Professions</button>
            </div>
        </div>

        <div id="map-screen" class="hidden">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400">World Map</h1>
            <div id="map-container" class="grid grid-cols-2 gap-4">
                </div>
            <div class="text-center mt-8">
                <button id="return-to-town-from-map" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Back to Town</button>
            </div>
        </div>

        <div id="shop-screen" class="hidden">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400">Blacksmith's Shop</h1>
            
            <div id="shop-npc-dialogue-container" class="bg-gray-700 p-6 rounded-xl flex flex-col items-center text-center mb-8">
                <img id="shop-npc-image" src="" alt="NPC" class="w-32 h-32 object-contain rounded-lg border-4 border-gray-600 bg-gray-900 mb-4">
                <h2 id="shop-npc-name" class="text-xl font-bold text-yellow-400"></h2>
                <p id="shop-npc-text" class="text-gray-300 mt-2 flex-grow"></p>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="bg-gray-700 p-6 rounded-xl">
                    <h2 class="text-2xl font-semibold mb-4 border-b-2 border-gray-600 pb-2">Wares for Sale</h2>
                    <div id="shop-inventory" class="space-y-3 max-h-96 overflow-y-auto"></div>
                </div>
                <div class="bg-gray-700 p-6 rounded-xl">
                    <div class="flex justify-between items-center mb-4 border-b-2 border-gray-600 pb-2">
                         <h2 class="text-2xl font-semibold">Your Inventory</h2>
                         <p class="text-yellow-400 font-bold">Gold: <span id="shop-player-gold">0</span></p>
                    </div>
                    <div id="player-sell-inventory" class="space-y-3 max-h-96 overflow-y-auto"></div>
                </div>
            </div>

            <div class="text-center mt-8">
                <button id="leave-shop" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Leave Shop</button>
            </div>
        </div>

		<div id="bank-screen" class="hidden">
			<h1 class="text-3xl md:text-4xl font-bold text-center mb-6 text-yellow-400">Player Bank</h1>
			
			<div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
				<div class="bg-gray-700 p-6 rounded-xl">
					<div class="flex justify-between items-center mb-4 border-b-2 border-gray-600 pb-2">
						 <h2 class="text-2xl font-semibold">Your Inventory</h2>
						 <p class="text-yellow-400 font-bold">Gold: <span id="bank-player-gold">0</span></p>
					</div>
					<p class="text-sm text-gray-400 mb-4">Click an item to deposit it into your bank.</p>
					<div id="bank-inventory-slots" class="grid grid-cols-5 gap-4"></div>
				</div>
				<div class="bg-gray-700 p-6 rounded-xl">
					<h2 class="text-2xl font-semibold mb-4 border-b-2 border-gray-600 pb-2">Bank Storage</h2>
					<p class="text-sm text-gray-400 mb-4">Click an item to withdraw it to your inventory.</p>
					<div id="bank-storage-slots" class="grid grid-cols-5 gap-4"></div>
					 <div class="text-center mt-6">
						<button id="buy-bank-slot-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Buy New Slot (400g)</button>
					</div>
				</div>
			</div>

			<div class="text-center mt-8">
				<button id="leave-bank-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Leave Bank</button>
			</div>
		</div>

        <div id="dungeon-screen" class="hidden">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-4 text-red-400">DUNGEON FLOOR <span id="dungeon-floor-number">1</span></h1>
            
            <!-- Combat Visual Area -->
            <div class="flex justify-around items-center mb-4 h-48">
                <img id="combat-player-image" src="" alt="Player" class="h-full object-contain">
                <div class="text-4xl font-bold text-gray-500">VS</div>
                <img id="combat-monster-image" src="" alt="Monster" class="h-full object-contain">
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 text-center">
                <!-- Player Area -->
                <div class="bg-gray-700 p-6 rounded-xl">
                    <h2 id="combat-player-name" class="text-2xl font-bold text-blue-400"></h2>
                    <div class="w-full health-bar-bg rounded-full h-4 mt-2 border-2 border-gray-600">
                        <div id="combat-player-health-bar" class="health-bar-fill h-full rounded-full"></div>
                    </div>
                    <p class="text-sm mt-1">HP: <span id="combat-player-hp"></span> / <span id="combat-player-max-hp"></span></p>
                    <div class="w-full health-bar-bg rounded-full h-4 mt-2 border-2 border-gray-600">
                        <div id="combat-player-mana-bar" class="mana-bar-fill h-full rounded-full"></div>
                    </div>
                    <p class="text-sm mt-1">Mana: <span id="combat-player-mana"></span> / <span id="combat-player-max-mana"></span></p>
                </div>

                <!-- Action Buttons -->    
                <div class="flex flex-col justify-center items-center gap-2">
                    <!-- Combat Attack Button-->
                    <button id="attack-btn" class="ability-button bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-xl w-full">Attack</button>
                    
                    <!-- Combat Item Button-->
                    <button id="items-btn" class="ability-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg w-full">Items</button>

                    <button id="run-btn" class="ability-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg w-full">Run</button>
                    
                    <!-- Combat Abilities -->
                    <div id="combat-abilities-container" class="w-full flex flex-col gap-2 mt-2"></div>

                    <!-- Hidden Container -->
                    <div id="combat-items-container" class="w-full flex-col gap-2 mt-2 hidden"></div>
                </div>

                <!-- Monster Area -->
                <div class="bg-gray-700 p-6 rounded-xl">
                    <h2 id="combat-monster-name" class="text-2xl font-bold text-red-400"></h2>
                    <div class="w-full health-bar-bg rounded-full h-4 mt-2 border-2 border-gray-600">
                        <div id="combat-monster-health-bar" class="health-bar-fill h-full rounded-full"></div>
                    </div>
                    <p class="text-sm mt-1">HP: <span id="combat-monster-hp"></span> / <span id="combat-monster-max-hp"></span></p>
                </div>
            </div>
             <div id="combat-results" class="text-center mt-8 hidden">
                <h2 id="results-title" class="text-3xl font-bold"></h2>
                <p id="results-rewards" class="text-yellow-400 mt-2"></p>
                <div class="flex justify-center gap-4 mt-4">
                    <button id="return-to-town-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Return to Town</button>
                    <button id="next-floor-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Next Floor</button>
                </div>
            </div>
        </div>
		
		<div id="achievement-screen" class="hidden">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-yellow-400">Achievements</h1>
            <p class="text-center text-lg text-gray-300 mb-6">Total Points: <span id="achievement-points" class="font-bold">0</span></p>
            <div id="achievement-container" class="space-y-4 max-h-[60vh] overflow-y-auto pr-4">
                </div>
            <div class="text-center mt-8">
                <button id="return-to-town-from-achievements" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Back to Town</button>
            </div>
        </div>
        
        <div id="game-log-container" class="mt-8">
            <h3 class="text-xl font-semibold mb-2 border-b-2 border-gray-700 pb-2">Game Log</h3>
            <div id="game-log" class="bg-gray-900 p-4 rounded-lg h-32 overflow-y-auto text-gray-300 text-sm"></div>
        </div>
    </div>

    <script>
		const firebaseConfig = {
		  apiKey: "AIzaSyDhB_WzVqo-NCCd1GCo7k7VqBXyE-qfi4Y",
		  authDomain: "dungeon-crawler-91f11.firebaseapp.com",
		  projectId: "dungeon-crawler-91f11",
		  storageBucket: "dungeon-crawler-91f11.firebasestorage.app",
		  messagingSenderId: "448104945557",
		  appId: "1:448104945557:web:346b8178b6c86e0b7e489c"
		};

		// Initialize Firebase
		firebase.initializeApp(firebaseConfig);

		// Get references to Firebase services IMMEDIATELY after init
		let auth = firebase.auth();
		let db = firebase.firestore();
        // --- DATA ---
        const abilities = {
            // Base Abilities
            power_strike: { name: 'Power Strike', description: 'A mighty blow dealing 150% Attack damage.', manaCost: 20, class: 'warrior', level: 1 },
            shield_bash: { name: 'Shield Bash', description: 'Slam your shield, dealing damage and lowering enemy Defense.', manaCost: 25, class: 'warrior', level: 3 },
            fireball: { name: 'Fireball', description: 'Hurls a ball of fire, dealing damage and burning the target over time.', manaCost: 25, class: 'wizard', level: 1 },
            frost_nova: { name: 'Frost Nova', description: 'An explosion of ice, dealing damage and lowering enemy Attack.', manaCost: 30, class: 'wizard', level: 3 },
            quick_strike: { name: 'Quick Strike', description: 'A rapid attack that may strike twice.', manaCost: 20, class: 'rogue', level: 1 },
            poison_stab: { name: 'Poison Stab', description: 'Stab with a poisoned blade, dealing damage and poisoning the target.', manaCost: 25, class: 'rogue', level: 3 },
            adrenaline_rush: { name: 'Adrenaline Rush', description: 'Temporarily boosts your Attack by 25%.', manaCost: 15, class: 'fighter', level: 1 },
            second_wind: { name: 'Second Wind', description: 'Heal for 25% of your maximum Health.', manaCost: 30, class: 'fighter', level: 3 },
            battle_cry: { name: 'Battle Cry', description: 'Increases Attack Power by 5.', manaCost: 5 },
            daze_enemy: { name: 'Daze Enemy', description: 'Chance to stun in battle for 2 turns.', manaCost: 10 },
            backstab_enemy: { name: 'Backstab Enemy', description: 'Attack with the power of 2 weapon strikes.', manaCost: 15 },
            rush_enemy: { name: 'Rush Enemy', description: 'Chance to stun in battle for 2 turns.', manaCost: 10 },

            // Wizard - Arcane
            confuse: { name: 'Confuse', description: 'Lower Enemy Attack and Defense for 2 Turns.', manaCost: 10, level: 6 },
            teleport_attack: { name: 'Teleport Attack', description: 'Attack enemy without any Enemy Defense.', manaCost: 30, level: 8 },
            corrupt: { name: 'Corrupt', description: 'Enemy will attack itself for 2 turns.', manaCost: 50, level: 10 },
            // Wizard - Frost
            frost_bolt: { name: 'Frost Bolt', description: '.5% Damage / Stun Enemy for 1 Turn.', manaCost: 10, level: 6 },
            freeze: { name: 'Freeze', description: 'Stun Enemy for 3 Turns.', manaCost: 30, level: 8 },
            ultimate_freeze: { name: 'Ultimate Freeze', description: 'Stun Enemy for 5 Turns.', manaCost: 50, level: 10 },
            // Wizard - Fire
            burn: { name: 'Burn', description: 'Burn for 1 turn and lower monster defense for 1 turn.', manaCost: 10, level: 6 },
            first_blast: { name: 'First Blast', description: 'Burn for 2 Turns.', manaCost: 30, level: 8 },
            fire_bomb: { name: 'Fire Bomb', description: 'Attack Enemy with 150% damage and set blow up for 10% of total enemy health.', manaCost: 50, level: 10 },
            // Warrior - Protection
            intimidate: { name: 'Intimidate', description: '.5% Damage / Stun Enemy for 1 Turn.', manaCost: 10, level: 6 },
            grab: { name: 'Grab', description: 'Stun Enemy for 2 Turns.', manaCost: 30, level: 8 },
            knock_out: { name: 'Knock Out', description: 'Stun Enemy for 3 Turns.', manaCost: 50, level: 10 },
            // Warrior - Fury
            spit: { name: 'Spit', description: 'Attack with 150% attack power.', manaCost: 10, level: 6 },
            fire_rage: { name: 'Fire Rage', description: 'For Next Attack, Burn Enemy for 2 Turns.', manaCost: 30, level: 8 },
            cloud_rage: { name: 'Cloud Rage', description: 'Lower Enemy Attack and Defense for 2 Turns.', manaCost: 50, level: 10 },
            // Warrior - Arms Master
            burning_blade_attack: { name: 'Burning Blade Attack', description: 'Attack with 135% Weapon Damage.', manaCost: 10, level: 6 },
            crit_hit: { name: 'Crit Hit', description: 'Increase critical to 100% for 3 turns.', manaCost: 30, level: 8 },
            boost_stats: { name: 'Boost Stats', description: 'Boost all stats for 3 turns by 8.', manaCost: 50, level: 10 },
            // Rogue - Assassin
            backstab: { name: 'Backstab', description: 'Attack enemy without any Enemy Defense.', manaCost: 10, level: 6 },
            crit_stab: { name: 'Crit Stab', description: 'Increase critical to 100% for 2 turns.', manaCost: 30, level: 8 },
            hurry_up_and_wait: { name: 'Hurry Up and Wait', description: 'Enemy will attack itself for 2 turns.', manaCost: 50, level: 10 },
            // Rogue - Subtlety
            percise_attack: { name: 'Percise Attack', description: 'Attack with 135% Attack Damage.', manaCost: 10, level: 6 },
            ambush: { name: 'Ambush', description: '.5% Damage / Stun Enemy for 1 Turn.', manaCost: 30, level: 8 },
            confuse_enemy: { name: 'Confuse Enemy', description: 'Lower Enemy Attack and Defense for 2 Turns.', manaCost: 50, level: 10 },
            // Rogue - Poison
            stun_poison: { name: 'Stun Poison', description: 'Stun Enemy for 2 Turns.', manaCost: 10, level: 6 },
            acid_poison: { name: 'Acid Poison', description: 'Burn for 1 turn and lower monster defense for 1 turn.', manaCost: 30, level: 8 },
            boost_all_stats: { name: 'Boost All Stats', description: 'Boost all stats for 3 turns by 8.', manaCost: 50, level: 10 },
            // Fighter - Attacker
            intimidate_fighter: { name: 'Intimidate', description: '.5% Damage / Stun Enemy for 1 Turn.', manaCost: 10, level: 6 },
            attack_advantage: { name: 'Attack Advantage', description: 'Stun Enemy for 2 Turns.', manaCost: 30, level: 8 },
            no_remorse: { name: 'No Remorse', description: 'Attack with 200% Attack Damage.', manaCost: 50, level: 10 },
            // Fighter - Defender
            power_strike_fighter: { name: 'Power Strike', description: 'Attack with 150% attack power.', manaCost: 10, level: 6 },
            boost_stats_fighter: { name: 'Boost Stats', description: 'Boost all stats for 3 turns by 5.', manaCost: 30, level: 8 },
            skull_bash: { name: 'Skull Bash', description: 'Stun Enemy for 3 Turns.', manaCost: 50, level: 10 },
            // Fighter - Gladiator
            spit_fighter: { name: 'Spit', description: 'Attack with 150% attack power.', manaCost: 10, level: 6 },
            rally_together: { name: 'Rally Together', description: 'Boost all stats for 3 turns by 8.', manaCost: 30, level: 8 },
            execute: { name: 'Execute', description: '50% Chance to Kill Enemy or deal 50% damage to yourself!', manaCost: 50, level: 10 },
        };

        const monsterAbilities = {
            rampage: { name: 'Rampage', description: 'The troll flies into a rage, dealing massive damage.' },
            lesser_heal: { name: 'Lesser Heal', description: 'The shaman heals itself for a small amount.' },
            minor_heal: { name: 'Minor Heal', description: 'A weak heal that restores a minor amount of health.' },
			forest_dragon_breath: { name: 'Rampant Growth', description: 'The dragon exhales a cloud of spores, poisoning you for two turns.' },
			swamp_dragon_venom: { name: 'Corrosive Spit', description: 'The dragon spits a glob of corrosive venom that ignores your defense.' },
			scorched_dragon_firestorm: { name: 'Ember Cascade', description: 'The dragon unleashes a wave of fire that burns you for three turns.' }
        };

        const classes = {
            warrior: { name: 'Warrior', description: 'A stalwart defender...', icon: '🛡️', image: 'images/Warrior.png', stats: { Health: 150, Mana: 50, Attack: 10, Defense: 15, Dexterity: 5, Intelligence: 5, CritChance: 0.05, CritDamage: 1.5 } },
            wizard: { name: 'Wizard', description: 'A master of the arcane...', icon: '🔥', image: 'images/Wizard.png', stats: { Health: 80, Mana: 100, Attack: 5, Defense: 5, Dexterity: 10, Intelligence: 20, CritChance: 0.05, CritDamage: 1.5 } },
            rogue: { name: 'Rogue', description: 'A swift and deadly assassin...', icon: '🗡️', image: 'images/Rogue.png', stats: { Health: 100, Mana: 50, Attack: 12, Defense: 8, Dexterity: 20, Intelligence: 5, CritChance: 0.10, CritDamage: 1.75 } },
            fighter: { name: 'Fighter', description: 'A versatile combatant...', icon: '⚔️', image: 'images/Fighter.png', stats: { Health: 120, Mana: 50, Attack: 12, Defense: 12, Dexterity: 12, Intelligence: 5, CritChance: 0.05, CritDamage: 1.5 } }
        };

        const subclasses = {
            wizard: {
                arcane: { name: 'Arcane', description: 'Masters of pure magical energy.', abilities: ['confuse', 'teleport_attack', 'corrupt'] },
                frost: { name: 'Frost', description: 'Controllers of ice and cold.', abilities: ['frost_bolt', 'freeze', 'ultimate_freeze'] },
                fire: { name: 'Fire', description: 'Pyromancers of immense power.', abilities: ['burn', 'first_blast', 'fire_bomb'] }
            },
            warrior: {
                protection: { name: 'Protection', description: 'Unyielding guardians of the battlefield.', abilities: ['intimidate', 'grab', 'knock_out'] },
                fury: { name: 'Fury', description: 'Berserkers who thrive in the heat of battle.', abilities: ['spit', 'fire_rage', 'cloud_rage'] },
                arms_master: { name: 'Arms Master', description: 'Weapon specialists of unmatched skill.', abilities: ['burning_blade_attack', 'crit_hit', 'boost_stats'] }
            },
            rogue: {
                assassin: { name: 'Assassin', description: 'Deadly masters of the killing blow.', abilities: ['backstab', 'crit_stab', 'hurry_up_and_wait'] },
                subtlety: { name: 'Subtlety', description: 'Shadowy figures who strike from nowhere.', abilities: ['percise_attack', 'ambush', 'confuse_enemy'] },
                poison: { name: 'Poison', description: 'Alchemists of death, using potent toxins.', abilities: ['stun_poison', 'acid_poison', 'boost_all_stats'] }
            },
            fighter: {
                attacker: { name: 'Attacker', description: 'Focused on overwhelming offensive power.', abilities: ['intimidate_fighter', 'attack_advantage', 'no_remorse'] },
                defender: { name: 'Defender', description: 'Stalwart protectors who control the fight.', abilities: ['power_strike_fighter', 'boost_stats_fighter', 'skull_bash'] },
                gladiator: { name: 'Gladiator', description: 'Crowd-pleasers who live for the thrill of combat.', abilities: ['spit_fighter', 'rally_together', 'execute'] }
            }
        };

        const rarities = {
            normal:    { name: 'Normal',    color: 'bg-transparent', textColor: 'text-white',       borderColor: 'border-normal' },
            common:    { name: 'Common',    color: 'bg-green-900/50',    textColor: 'text-green-400',   borderColor: 'border-common' },
            rare:      { name: 'Rare',      color: 'bg-blue-900/50',     textColor: 'text-blue-400',    borderColor: 'border-rare' },
            epic:      { name: 'Epic',      color: 'bg-purple-900/50',   textColor: 'text-purple-400',  borderColor: 'border-epic' },
            legendary: { name: 'Legendary', color: 'bg-orange-900/50',   textColor: 'text-orange-400',  borderColor: 'border-legendary' },
            elite:     { name: 'Elite',     color: 'bg-red-900/50',      textColor: 'text-red-400',     borderColor: 'border-elite' }
        };

        const items = {
            admin_sword: { name: 'Admin Sword', type: 'weapon', slot: 'weapon', stats: { Attack: 100 }, icon: 'images/admin-sword.png', value: 1, rarity: 'normal', description: 'Cheaters win', hand: 'one', set: 'admin', minLevel: 1 },
            rusty_sword: { name: 'Rusty Sword', type: 'weapon', slot: 'weapon', stats: { Attack: 1 }, icon: '🗡️', value: 5, rarity: 'normal', description: 'An old, dull sword.', upgradesTo: 'common_sword', upgradeCost: 25, hand: 'one', minLevel: 1 },
            common_sword: { name: 'Sword', type: 'weapon', slot: 'weapon', stats: { Attack: 2, Defense: 2 }, icon: '🗡️', value: 10, rarity: 'common', description: 'A standard-issue sword.', hand: 'one', minLevel: 2 },
            common_attack_sword: { name: 'Sword', type: 'weapon', slot: 'weapon', stats: { Attack: 5 }, icon: '🗡️', value: 10, rarity: 'common', description: 'Sharper than a common sword', hand: 'one', minLevel: 2 },
            common_defense_sword: { name: 'Sword', type: 'weapon', slot: 'weapon', stats: { Defense: 5 }, icon: '🗡️', value: 10, rarity: 'common', description: 'Wider than a common sword', hand: 'one', minLevel: 2 },
            rusty_great_sword: { name: 'Rusty Great Sword', type: 'weapon', slot: 'weapon', stats: { Attack: 4 }, icon: '🗡️', value: 5, rarity: 'normal', description: 'An old, dull sword.', upgradesTo: 'common_great_sword', upgradeCost: 25, hand: 'two', minLevel: 1 },
            common_great_sword: { name: 'Great Sword', type: 'weapon', slot: 'weapon', stats: { Attack: 9 }, icon: '🗡️', value: 10, rarity: 'common', description: 'A standard-issue sword.', hand: 'two', minLevel: 2 },            
            rusty_great_axe: { name: 'Rusty Great Axe', type: 'weapon', slot: 'weapon', stats: { Attack: 5 }, icon: '🪓', value: 5, rarity: 'normal', description: 'An old, dull sword.', upgradesTo: 'common_great_axe', upgradeCost: 25, hand: 'two', minLevel: 1 },
            common_great_axe: { name: 'Great Axe', type: 'weapon', slot: 'weapon', stats: { Attack: 10 }, icon: '🪓', value: 15, rarity: 'common', description: 'Big Axes mean....', hand: 'two', minLevel: 2 },
            rusty_dagger: { name: 'Rusty Dagger', type: 'weapon', slot: 'weapon', stats: { Attack: 1, Dexterity: 1 }, icon: '🗡️', value: 4, rarity: 'normal', description: 'A small, dull dagger.', hand: 'one', minLevel: 1 },
            bent_staff: { name: 'Bent Staff', type: 'weapon', slot: 'weapon', stats: { Intelligence: 1 }, icon: '🪄', value: 4, rarity: 'normal', description: 'A crooked piece of wood.', hand: 'two', minLevel: 2 },
            tat_cloth_shirt: { name: 'Tattered Cloth Shirt', type: 'armor', slot: 'chest', stats: { Defense: 1, Intelligence: 1 }, icon: '👕', value: 3, rarity: 'normal', description: 'Better than nothing.', upgradesTo: 'common_cloth_shirt', upgradeCost: 20, minLevel: 1 },
            common_cloth_shirt: { name: 'Cloth Shirt', type: 'armor', slot: 'chest', stats: { Defense: 3, Intelligence: 4 }, icon: '👕', value: 3, rarity: 'normal', description: 'Better than nothing.', minLevel: 2 },
            tat_leather_shirt: { name: 'Tattered Leather Shirt', type: 'armor', slot: 'chest', stats: { Defense: 1, Health: 5 }, icon: '👕', value: 3, rarity: 'normal', description: 'Better than nothing.', upgradesTo: 'common_leather_shirt', upgradeCost: 20, minLevel: 1 },
            common_leather_shirt: { name: 'Leather Shirt', type: 'armor', slot: 'chest', stats: { Defense: 3, Health: 10 }, icon: '👕', value: 15, rarity: 'normal', description: 'Better than nothing.', minLevel: 2 },
            tat_leather_boots: { name: 'Tattered Leather Boots', type: 'armor', slot: 'boots', stats: { Defense: 1, Dexterity: 2 }, icon: '👢', value: 3, rarity: 'normal', description: 'Better than nothing.', upgradesTo: 'common_leather_boots', upgradeCost: 20, minLevel: 1 },
            common_leather_boots: { name: 'Leather Boots', type: 'armor', slot: 'boots', stats: { Defense: 3, Dexterity: 5 }, icon: '👢', value: 15, rarity: 'normal', description: 'Better than nothing.', minLevel: 2 },
            tat_cloth_boots: { name: 'Tattered Cloth Boots', type: 'armor', slot: 'boots', stats: { Defense: 1, Dexterity: 1 }, icon: '👢', value: 2, rarity: 'normal', description: 'Better than nothing.', upgradesTo: 'common_cloth_boots', upgradeCost: 20, minLevel: 1 },
            common_cloth_boots: { name: 'Leather Boots', type: 'armor', slot: 'boots', stats: { Defense: 3, Dexterity: 3 }, icon: '👢', value: 10, rarity: 'normal', description: 'Better than nothing.', minLevel: 2 },
            tat_cloth_gloves: { name: 'Tattered Cloth Gloves', type: 'armor', slot: 'gloves', stats: { Defense: 1, Mana: 6 }, icon: '🧤', value: 2, rarity: 'normal', description: 'Better than nothing.', upgradesTo: 'common_cloth_gloves', upgradeCost: 20, minLevel: 1 },
            common_cloth_gloves: { name: 'Cloth Gloves', type: 'armor', slot: 'gloves', stats: { Defense: 3, Mana: 14 }, icon: '🧤', value: 10, rarity: 'normal', description: 'Better than nothing.', minLevel: 2 },
            tat_leather_gloves: { name: 'Tattered Leather Gloves', type: 'armor', slot: 'gloves', stats: { Defense: 2, Mana: 4 }, icon: '🧤', value: 2, rarity: 'normal', description: 'Better than nothing.', upgradesTo: 'common_leather_gloves', upgradeCost: 20, minLevel: 1 },
            common_leather_gloves: { name: 'Leather Gloves', type: 'armor', slot: 'gloves', stats: { Defense: 5, Mana: 9 }, icon: '🧤', value: 10, rarity: 'normal', description: 'Better than nothing.', minLevel: 2 },
            common_leather_cap: { name: 'Leather Cap', type: 'armor', slot: 'head', stats: { Defense: 3 }, icon: '🧢', value: 8, rarity: 'common', description: 'A simple leather cap.', minLevel: 2 },
            common_vitality_shirt: { name: 'Shirt of Vitality', type: 'armor', slot: 'chest', stats: { Health: 15 }, icon: '👕', value: 12, rarity: 'common', description: 'Imbued with a touch of life.', minLevel: 3 },
            rare_staff: { name: 'Sage\'s Staff', type: 'weapon', slot: 'weapon', stats: { Intelligence: 5, Mana: 10 }, icon: '🪄', value: 25, rarity: 'rare', description: 'A staff for a budding wizard.', requirements: { class: 'wizard' }, minLevel: 4 },
            rare_iron_gloves: { name: 'Iron Gloves', type: 'armor', slot: 'gloves', stats: { Dexterity: 3, Defense: 2 }, icon: '🧤', value: 25, rarity: 'rare', description: 'Sturdy and reliable.', minLevel: 4 },
            epic_swiftness_boots: { name: 'Boots of Swiftness', type: 'armor', slot: 'boots', stats: { Dexterity: 6 }, icon: '👢', value: 50, rarity: 'epic', description: 'Feel the wind at your heels.', requirements: { level: 3 }, minLevel: 3 },
            iron_militia_helm: { name: 'Iron Militia Scaled Helm', type: 'armor', slot: 'head', stats: { Defense: 3, Health: 10 }, icon: '🧢', value: 100, rarity: 'epic', set: 'iron_militia', minLevel: 4 },
            iron_militia_plate: { name: 'Iron Militia Scaled Plate', type: 'armor', slot: 'chest', stats: { Defense: 3, Attack: 10 }, icon: '👕', value: 100, rarity: 'epic', set: 'iron_militia', minLevel: 4 },
            iron_militia_gloves: { name: 'Iron Militia Scaled Glooves', type: 'armor', slot: 'gloves', stats: { Defense: 3, Intelligence: 10 }, icon: '🧤', value: 100, rarity: 'epic', set: 'iron_militia', minLevel: 4 },
            iron_militia_boots: { name: 'Iron Militia Scaled Boots', type: 'armor', slot: 'boots', stats: { Defense: 3, Dexterity: 10 }, icon: '👢', value: 100, rarity: 'epic', set: 'iron_militia', minLevel: 4 },
            iron_militia_pants: { name: 'Iron Militia Scaled Pants', type: 'armor', slot: 'legs', stats: { Defense: 3, Mana: 10 }, icon: '👖', value: 100, rarity: 'epic', set: 'iron_militia', minLevel: 4 },
            health_potion: { name: 'Health Potion', type: 'consumable', slot: 'consumable', description: 'Restores 50 health.', effect: { type: 'heal', amount: 50 }, icon: '🧪', value: 15, rarity: 'common', stackable: true, minLevel: 1 },
            mana_potion: { name: 'Mana Potion', type: 'consumable', slot: 'consumable', description: 'Restores 30 mana.', effect: { type: 'mana_heal', amount: 30 }, icon: '💧', value: 20, rarity: 'common', stackable: true, minLevel: 1 },
            potion_of_strength: { name: 'Potion of Strength', type: 'consumable', slot: 'consumable', description: 'Boosts Attack by 5 for the next combat.', effect: { type: 'temp_buff', stat: 'Attack', amount: 5 }, icon: '💪', value: 30, rarity: 'rare', stackable: true, minLevel: 1 },
            potion_of_toughness: { name: 'Potion of Toughness', type: 'consumable', slot: 'consumable', description: 'Boosts Defense by 5 for the next combat.', effect: { type: 'temp_buff', stat: 'Defense', amount: 5 }, icon: '🛡️', value: 30, rarity: 'rare', stackable: true, minLevel: 1 },
            //Trash Loot  // PURCHASABLE: FLASE >>>>
            goblin_ear: { name: 'Goblin Ear', type: 'junk', slot: 'junk', description: 'A grotesque trophy.', icon: '👂', value: 2, rarity: 'normal', stackable: true, purchasable: false },
            dirt: { name: 'Dirt', type: 'junk', slot: 'junk', description: 'A pile of mud.', icon: '🟤', value: 0, rarity: 'normal', stackable: true, purchasable: false},
            bone_fragment: { name: 'Bone Fragment', type: 'junk', slot: 'junk', description: 'A piece of a skeleton.', icon: '🦴', value: 3, rarity: 'normal', stackable: true, purchasable: false },
            rotten_meat: { name: 'Rotten Meat', type: 'junk', slot: 'junk', description: 'A disgusting piece of flesh.', icon: '🥩', value: 1, rarity: 'normal', stackable: true, purchasable: false },
            //Legacy Gear
            legacy_warrior_breastplate: { name: 'Legacy Warrior BreastPlate', type: 'armor', slot: 'chest', stats: { Attack: 15, Health: 20 }, icon: '👕', value: 0, rarity: 'legendary', description: 'A blade for a Warrior God.', requirements: { level: 8 }, set: 'god', purchasable: false },
            legacy_wizard_gloves: { name: 'Legacy Wizard Gloves', type: 'armor', slot: 'gloves', stats: { Intelligence: 15, Mana: 20 }, icon: '🧤', value: 0, rarity: 'legendary', description: 'A staff for a Wizard God.', requirements: { level: 8 }, set: 'god', purchasable: false },
            legacy_rogue_boots: { name: 'Legacy Rogue Boots', type: 'armor', slot: 'boots', stats: { Dexterity: 15, CritChance: 0.05 }, icon: '👢', value: 0, rarity: 'legendary', description: 'A dagger for a Rogue God.', requirements: { level: 8 }, set: 'god', purchasable: false },
            legacy_fighter_pants: { name: 'Legacy Fighter Pants', type: 'armor', slot: 'pants', stats: { Attack: 10, Defense: 5 }, icon: '👖', value: 0, rarity: 'legendary', description: 'A sword for a Fighter God.', requirements: { level: 8 }, set: 'god', purchasable: false },
            // Class Items 
            sigil_of_retribution: { name: 'Sigil of Retribution', type: 'armor', slot: 'special', stats: { Defense: 10 }, description: 'When hit, you have a 15% chance to retaliate for 50% of your Attack damage.', icon: '🛡️', value: 150, rarity: 'epic', requirements: { class: 'warrior' }, questRewardOnly: true, purchasable: false },
            relic_of_manaflame: { name: 'Relic of Manaflame', type: 'armor', slot: 'special', stats: { Intelligence: 12, Mana: 25 }, description: 'Your fire spells cost 10% less mana to cast.', icon: '🔥', value: 150, rarity: 'epic', requirements: { class: 'wizard' }, questRewardOnly: true, purchasable: false },
            gadget_caltrops: { name: 'Bag of Caltrops', type: 'armor', slot: 'special', stats: { Dexterity: 15 }, description: 'At the start of combat, you have a chance to slow the enemy, reducing their Attack.', icon: '⚙️', value: 150, rarity: 'epic', requirements: { class: 'rogue' }, questRewardOnly: true, purchasable: false },
            medallion_of_valor: { name: 'Medallion of Valor', type: 'armor', slot: 'special', stats: { Health: 20, Attack: 5 }, description: 'For every 25% of health you are missing, you gain +5 Defense.', icon: '🎖️', value: 150, rarity: 'epic', requirements: { class: 'fighter' }, questRewardOnly: true, purchasable: false },
            //Quest Items
			slimy_glob: { name: 'Slimy Glob', type: 'junk', slot: 'junk', description: 'A viscous, quivering piece of a swamp creature.', icon: '🟢', value: 0, rarity: 'normal', stackable: true, questItem: true, purchasable: false },
			pheonix_feather: { name: 'Pheonix Feather', type: 'junk', slot: 'junk', description: 'Feather of a firey bird', icon: '🪶', value: 0, rarity: 'normal', stackable: true, questItem: true, purchasable: false},
			small_electronics: { name: 'Bundle of Wires', type: 'junk', slot: 'junk', description: 'From a drone', icon: '🔌', value: 0, rarity: 'normal', stackable: true, purchasable: false},
            goblin_blood: { name: 'Hot Goblin Blood', type: 'junk', slot: 'junk', description: 'Sticky..lots of iron', icon: '🔴', value: 0, rarity: 'normal', stackable: true, purchasable: false},
            frost_core: { name: 'Frost Core', type: 'junk', slot: 'junk', description: 'The frozen heart of an elemental.', icon: '❄️', value: 0, rarity: 'normal', stackable: true, purchasable: false },
            elemental_core: { name: 'Elemental Core', type: 'junk', slot: 'junk', description: 'Heart of the forest spirit.', icon: '💚', value: 0, rarity: 'normal', stackable: true, questItem: true, purchasable: false },
            // Dragon Keys + Map Pieces to Dragon Wasteland
            ff_dragon_key: { name: 'Key to the Forst Dragon', type: 'junk', slot: 'junk', description: 'Heavy iron key', icon: '🗝️', value: 0, rarity: 'legendary', stackable: true, purchasable: false},
            ss_dragon_key: { name: 'Key to the Swamp Dragon', type: 'junk', slot: 'junk', description: 'Heavy iron key', icon: '🗝️', value: 0, rarity: 'legendary', stackable: true, purchasable: false},
            sp_dragon_key: { name: 'Key to the Scorched Dragon', type: 'junk', slot: 'junk', description: 'Heavy iron key', icon: '🗝️', value: 0, rarity: 'legendary', stackable: true, purchasable: false},
            fp_dragon_key: { name: 'Key to the Frozen Dragon', type: 'junk', slot: 'junk', description: 'Heavy iron key', icon: '🗝️', value: 0, rarity: 'legendary', stackable: true, purchasable: false},
			ff_dragon_head: { name: 'Head of the Forsest Dragon', type: 'junk', slot: 'junk', description: 'Heavy iron key', icon: '🗝', value: 0, rarity: 'legendary', stackable: true, purchasable: false},
            map_piece_1: { name: 'The bottom left quad of a map', type: 'junk', slot: 'junk', description: 'Partially burnt but readable', icon: '🗺️', value: 0, rarity: 'legendary', purchasable: false},
            map_piece_2: { name: 'The bottom right quad of a map', type: 'junk', slot: 'junk', description: 'Partially burnt but readable', icon: '🗺️', value: 0, rarity: 'legendary', purchasable: false},
            map_piece_3: { name: 'The top left quad of a map', type: 'junk', slot: 'junk', description: 'Partially burnt but readable', icon: '🗺️', value: 0, rarity: 'legendary', purchasable: false},
            map_piece_4: { name: 'The top right quad of a map', type: 'junk', slot: 'junk', description: 'Partially burnt but readable', icon: '🗺️', value: 0, rarity: 'legendary', purchasable: false},
            // Crafting Stuffs
            tattered_cloth: { name: 'Tattered Cloth', type: 'material', slot: 'material', description: 'Scraps of old cloth.', icon: '📜', value: 1, rarity: 'normal', stackable: true },
            iron_ore: { name: 'Iron Ore', type: 'material', slot: 'material', description: 'A chunk of raw iron.', icon: '⚫', value: 3, rarity: 'normal', stackable: true },
            marigold_flower: { name: 'Marigold Flower', type: 'material', slot: 'material', description: 'Herb used for health potions.', icon: '🌿', value: 5, rarity: 'normal', stackable: true }
        };

        const recipes = {
            simple_healing_potion_recipe: {
                name: 'Simple Healing Potion',
                itemId: 'health_potion', // The key of the item this recipe creates
                profession: 'herbalism',
                materials: {
                    marigold_flower: 5 // Requires 5 'marigold_flowers'
                }
            },
            iron_sword_recipe: {
                name: 'Iron Sword',
                itemId: 'common_sword',
                profession: 'blacksmithing',
                materials: {
                    iron_ore: 5,
                    tattered_cloth: 2
                }
            },
        };

        const setBonuses = {
            // Set Bonus - Defined by unique name 
            iron_militia: {
                2: { stats: { Defense: 5 }, description: "2 Pieces: +5 Defense" },
                3: { stats: { Health: 20 }, description: "3 Pieces: +25 Health" },
                4: { stats: { Mana: 20 }, description: "4 Pieces: +20 Mana" }
            },
            admin: {
                2: { stats: { Defense: 1000, Attack: 1000, Dexterity: 1000, Intelligence: 1000, Mana: 1000 }, description: "Break the game" }
            },
            godset: {
                2: { stats: { Defense: 1000, Attack: 1000, Dexterity: 1000, Intelligence: 1000, Mana: 1000 }, description: "Break the game" }
            }
            
        };    
		
		const achievements = {
			// Level Achievements
			reach_level_2:  { name: "Novice Adventurer", description: "Reach level 2.", icon: '🏆', points: 10, type: 'level', value: 2 },
			reach_level_5:  { name: "Seasoned Explorer", description: "Reach level 5.", icon: '🏆', points: 20, type: 'level', value: 5 },
			reach_level_10: { name: "Veteran Warrior",   description: "Reach level 10.", icon: '🏆', points: 30, type: 'level', value: 10 },
			reach_level_15: { name: "Elite Champion",    description: "Reach level 15.", icon: '🏆', points: 40, type: 'level', value: 15 },
			reach_level_20: { name: "Living Legend",     description: "Reach level 20.", icon: '🏆', points: 50, type: 'level', value: 20 },

			// Dungeon Floor Achievements
			reach_floor_5:  { name: "Deeper and Deeper", description: "Reach dungeon floor 5.", icon: '🏆', points: 10, type: 'dungeon', value: 5 },
			reach_floor_10: { name: "Abyss Gazer",       description: "Reach dungeon floor 10.", icon: '🏆', points: 20, type: 'dungeon', value: 10 },
			reach_floor_15: { name: "Hell Diver",        description: "Reach dungeon floor 15.", icon: '🏆', points: 30, type: 'dungeon', value: 15 },
			reach_floor_20: { name: "Core Reacher",      description: "Reach dungeon floor 20.", icon: '🏆', points: 40, type: 'dungeon', value: 20 },
			reach_floor_25: { name: "Dungeon Master",    description: "Reach dungeon floor 25.", icon: '🏆', points: 50, type: 'dungeon', value: 25 },
			reach_floor_30: { name: "Empty Depths",      description: "Reach dungeon floor 30.", icon: '🏆', points: 60, type: 'dungeon', value: 30 },

			// Boss Kill Achievements
			kill_orc_chieftain: { name: "Chieftain Slayer", description: "Defeat the Troll Chieftain in the Forgotten Forest.", monsterId: 'orc_chieftain', icon: '🏆', points: 25 },
			kill_bro_sr: { name: "Forest on Fire?", description: "Defeat the Forest Dragon.", monsterId: 'forest_dragon', icon: '🏆', points: 50 },


			// Quest Completion Achievements
			complete_forest_quests: { name: "Friend of the Forest", description: "Complete all quests in the Forgotten Forest.", area: 'forgotten_forest', icon: '🏆', points: 50 },
		};

        const monsters = {
            goblin: { name: 'Goblin', image: 'goblin.png', stats: { Health: 30, Attack: 5, Defense: 4, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [3, 7], xp: 8, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'goblin_ear', chance: 0.5 },{ itemId: 'marigold_flower', chance: 0.5},{ itemId: 'iron_ore', chance: 0.25}] },
            goblin_warrior: { name: 'Goblin Warrior', image: 'goblinwarrior.png', stats: { Health: 40, Attack: 8, Defense: 5, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [5, 12], xp: 15, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'goblin_ear', chance: 0.5 }] },
            goblin_shaman: { name: 'Goblin Shaman', image: 'goblin_shaman.png', stats: { Health: 40, Attack: 6, Defense: 3, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [5, 12], xp: 15, type: 'normal', abilities: [{ id: 'lesser_heal', chance: 0.25 }], levelRange: [2, 100], loot: [{ itemId: 'goblin_ear', chance: 0.75 }] },
            goblin_elder_shaman: { name: 'Goblin Elder Shaman', image: 'goblin_elder_shaman.png', stats: { Health: 50, Attack: 10, Defense: 6, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [12, 18], xp: 25, type: 'normal', abilities: [{ id: 'lesser_heal', chance: 0.2 }], levelRange: [10, 100], loot: [{ itemId: 'goblin_ear', chance: 0.75 }] },
            snake: { name: 'Snake in the Grass', image: 'snake.png', stats: { Health: 5, Attack: 20, Defense: 10, CritChance: 0.5, CritDamage: 1.5 }, goldRange: [1, 2], xp: 5, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'dirt', chance: 0.5 }] },
            raider: { name: 'Raider', image: 'raider.png', stats: { Health: 60, Attack: 12, Defense: 5, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [8, 12], xp: 18, type: 'normal', levelRange: [3, 100], loot: [{ itemId: 'health_potion', chance: 0.75 }] },
            orc_brute: { name: 'Orc Brute', image: 'orc_brute.png', stats: { Health: 60, Attack: 10, Defense: 8, CritChance: 0.10, CritDamage: 1.5 }, goldRange: [15, 22], xp: 30, type: 'normal', levelRange: [12, 100] },
            orc_mage: { name: 'Orc Mage', image: 'orc_mage.png', stats: { Health: 40, Attack: 15, Defense: 1, CritChance: 0.10, CritDamage: 1.5 }, goldRange: [14, 21], xp: 30, type: 'normal', levelRange: [12, 100] },
            orc_priest: { name: 'Orc Priest', image: 'orc_priest.png', stats: { Health: 20, Attack: 5, Defense: 2, CritChance: 0.10, CritDamage: 1.5 }, goldRange: [14, 20], xp: 30, abilities: [{ id: 'minor_heal', chance: 0.2 }], type: 'normal', levelRange: [12, 100] },
            orc_chieftain: { name: 'Orc Chieftain', image: 'orc_chieftain.png', stats: { Health: 200, Attack: 20, Defense: 12, CritChance: 0.15, CritDamage: 1.6 }, goldRange: [90, 110], xp: 75, type: 'boss', abilities: [{ id: 'rampage', chance: 0.25 }] },
            forest_elemental: { name: 'Forest Elemental' , image: 'forestelemental.png', stats: { Health: 50, Attack: 25, Defense: 10, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [40, 60], xp: 200, type: 'normal', levelRange: [5, 100], loot: [{ itemId: 'elemental_core', chance: 0.5 }] },
			
            // Sunken Swamps
            ghoul: { name: 'Ghoul', image: 'ghoul.png', stats: { Health: 20, Attack: 5, Defense: 2, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [3, 7], xp: 12, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'dirt', chance: 0.5 }] },
            skeleton: { name: 'Skeleton', image: 'skeleton.png', stats: { Health: 50, Attack: 10, Defense: 6, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [8, 12], xp: 15, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'bone_fragment', chance: 0.75 }] },
            zombie: { name: 'Zombie', image: 'zombie.png', stats: { Health: 30, Attack: 8, Defense: 4, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [3, 7], xp: 10, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'rotten_meat', chance: 0.5 }] },
            primordial_ooze: { name: 'Primordial Ooze', image: 'ooze.png', stats: { Health: 100, Attack: 9, Defense: 10, CritChance: 1, CritDamage: 1.5 }, goldRange: [20, 30], xp: 100, type: 'normal', levelRange: [1, 100] },
            undead_swamp_lizard: { name: 'Undead Swamp Lizard', image: 'swamplizard.png', stats: { Health: 200, Attack: 12, Defense: 10, CritChance: 1, CritDamage: 1.5 }, goldRange: [20, 30], xp: 100, type: 'boss', levelRange: [1, 100] },
            blobmonster: { name: 'Blob Monster', image: 'blob.png', stats: { Health: 500, Attack: 2, Defense: 10, CritChance: 1, CritDamage: 1.5 }, goldRange: [20, 30], xp: 100, type: 'normal', levelRange: [1, 100] },

            //Scorched Plains
            flock_of_birds: { name: 'Flock of Angry Birds', image: 'flockofbirds.png', stats: { Health: 30, Attack: 8, Defense: 5, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [3, 7], xp: 12, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'small_electronics', chance: 1 }] },
            vulture: { name: 'Vulture', image: 'vulture.png', stats: { Health: 40, Attack: 9, Defense: 6, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [3, 15], xp: 22, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'small_electronics', chance: 1 }] },
			pheonix: { name: 'Pheonix', image: 'pheonix.png', stats: { Health: 30, Attack: 8, Defense: 5, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [3, 15], xp: 20, type: 'normal', levelRange: [1, 100] },
            fire_elemental: { name: 'Fire Elemental', image: 'fireelemental.png', stats: { Health: 250, Attack: 18, Defense: 16, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [30, 40], xp: 120, type: 'boss', levelRange: [1, 100] },
            
            //Frozen Peaks
            ice_golem: { name: 'Ice Golem', image: 'icegolem.png', stats: { Health: 280, Attack: 25, Defense: 30, CritChance: 0.05, CritDamage: 1.5 }, goldRange: [40, 60], xp: 150, type: 'normal', levelRange: [1, 100], loot: [{ itemId: 'frost_core', chance: 0.5 }] },
            yeti: { name: 'Yeti', image: 'yeti.png', stats: { Health: 320, Attack: 35, Defense: 25, CritChance: 0.1, CritDamage: 1.6 }, goldRange: [50, 75], xp: 180, type: 'normal', levelRange: [1, 100] },
            ice_giant: { name: 'Ice Giant', image: 'icegiant.png', stats: { Health: 800, Attack: 50, Defense: 40, CritChance: 0.15, CritDamage: 1.7 }, goldRange: [200, 250], xp: 500, type: 'boss' },
            
            
            // Dragons 
            forest_dragon: { name: 'Forest Dragon', image: 'forestdragon.png', stats: { Health: 300, Attack: 30, Defense: 20, CritChance: 0.15, CritDamage: 1.6 }, goldRange: [90, 110], xp: 150, type: 'boss', abilities: [{ id: 'forest_dragon_breath', chance: 0.5 }] },
			swamp_dragon: { name: 'Swamp Dragon', image: 'swampdragon.png', stats: { Health: 300, Attack: 30, Defense: 20, CritChance: 0.15, CritDamage: 1.6 }, goldRange: [90, 110], xp: 150, type: 'boss', abilities: [{ id: 'swamp_dragon_venom', chance: 0.5 }] },
			scorched_dragon: { name: 'Scorched Dragon', image: 'scorcheddragon.png', stats: { Health: 300, Attack: 30, Defense: 20, CritChance: 0.15, CritDamage: 1.6 }, goldRange: [90, 110], xp: 150, type: 'boss', abilities: [{ id: 'scorched_dragon_firestorm', chance: 0.5 }] },
            frozen_dragon: { name: 'Frozen Dragon', image: 'frozendragon.png', stats: { Health: 1000, Attack: 60, Defense: 50, CritChance: 0.2, CritDamage: 1.8 }, goldRange: [300, 400], xp: 800, type: 'boss' },
        };

        const npcs = {
            forgotten_forest: {
                vendor: {
                    name: 'Grumble Ironhand',
                    image: 'images/grumble-ironhand-blacksmith.png',
                    dialogue: {
                        intro: "A new face. Don't waste my time. What do you need, adventurer?",
                        level_5: "Hmph. You've survived this long. Maybe you're not entirely useless. I've got some higher quality gear that might interest you."
                    }
                },
                questGiver: {
                    name: 'Seraphina',
                    image: 'images/questgiver.png',
                    dialogue: {
                        intro: "Welcome, adventurer. The board is full of requests from folks in need. See if there's anything you can handle.",
                    }
                },
                classTrainer: {
                    name: 'Master Valerius',
                    image: 'https://placehold.co/128x128/1f2937/ffffff?text=Trainer',
                    dialogue: {
                        intro: "You've shown promise, but your true path has yet to be chosen. Specialization requires dedication... and coin. Are you ready?"
                    }
                },
                godsTrainer: {
                    name: 'The Emissary',
                    image: 'https://placehold.co/128x128/1f2937/ffffff?text=Gods',
                    dialogue: {
                        intro: "The gods are always watching. Your deeds have not gone unnoticed. Show your devotion and they may grant you their favor."
                    }
                }
            },
            sunken_swamp: {
                vendor: {
                    name: 'Mirella Rust-Eater',
                    image: 'swamp-vendor.png',
                    dialogue: {
                        intro: "Everything's damp here... including the coin. If you've got some, I've got wares that won't rust away in a day.",
                        level_5: "You've got the swamp-stare. Good. Means you're tough enough for my better stock."
                    }
                },
                questGiver: {
                    name: 'Old Man Willow',
                    image: 'swamp-questgiver.png',
                    dialogue: {
                        intro: "The bog groans under the weight of the undead. Help quell the rot, and you might earn your keep."
                    }
                },
                classTrainer: {
                    name: 'Hermit of the Fen',
                    image: 'swamp-trainer.png',
                    dialogue: {
                        intro: "Power can be found in stillness, in the quiet decay of the swamp. To specialize is to understand that. Show me your coin."
                    }
                },
                godsTrainer: {
                    name: 'Whisper in the Reeds',
                    image: 'swamp-gods.png',
                    dialogue: {
                        intro: "The old gods slumber in the deep waters. Their power is subtle, patient. Show them your worth."
                    }
                }
            },
            scorched_plains: {
                vendor: {
                    name: 'Anvil Rustgut',
                    image: 'scorched-vendor.png',
                    dialogue: {
                        intro: "The heat doesn't help, but it could hurt more.",
                    }
                },
                questGiver: {
                    name: 'Plains General',
                    image: 'scorched-questgiver.png',
                    dialogue: {
                        intro: "We are under attack! We need your help to take down our foes."
                    }
                },
                classTrainer: {
                    name: 'Sergent Ironfoot',
                    image: 'scorched-trainer.png',
                    dialogue: {
                        intro: "Classes mean nothing here. Enemies are about."
                    }
                },
                godsTrainer: {
                    name: 'Axes Sootbeard',
                    image: 'scorched-gods.png',
                    dialogue: {
                        intro: "Humphh...Always in it for the reputation. Never for the glory."
                    }
                }
            },
            frozen_peak: {
                vendor: {
                    name: 'Granite Coldfist',
                    image: 'frozen-vendor.png',
                    dialogue: {
                        intro: "At least the heat warms my dead hands. Come in and take a look around.",
                    }
                },
                questGiver: {
                    name: 'Mountian Village Chief',
                    image: 'frozen-questgiver.png',
                    dialogue: {
                        intro: "We are under attack! We need your help to take down our foes."
                    }
                },
                classTrainer: {
                    name: 'Mountian Village Class Trainer',
                    image: 'frozen-trainer.png',
                    dialogue: {
                        intro: "Classes mean nothing here. Enemies are about."
                    }
                },
                godsTrainer: {
                    name: 'Mountian Village Gods Trainer',
                    image: 'frozen-gods.png',
                    dialogue: {
                        intro: "Humphh...Always in it for the reputation. Never for the glory."
                    }
                }
            },
            dragon_wastelands: {
                vendor: {
                    name: 'Wasteland Scavenger',
                    image: 'dragon-vendor.png',
                    dialogue: {
                        intro: "Not much left out here but dust and bones. But what I find... it's worth a pretty penny.",
                    }
                },
                questGiver: {
                    name: 'Ancient Chronicler',
                    image: 'dragon-questgiver.png',
                    dialogue: {
                        intro: "The history of this place is written in the scars on the land. Help me uncover its secrets."
                    }
                },
                classTrainer: {
                    name: 'Dragon-Blooded Master',
                    image: 'dragon-trainer.png',
                    dialogue: {
                        intro: "True power comes not from steel, but from the ancient blood within. Are you worthy of it?"
                    }
                },
                godsTrainer: {
                    name: 'Echo of the First Wyrm',
                    image: 'dragon-gods.png',
                    dialogue: {
                        intro: "The dragon gods do not speak. They watch. Your actions will be your prayer."
                    }
                }
            }
        };
		const guideNPC = {
			name: 'The Old Adventurer',
			image: 'https://placehold.co/128x128/1a202c/cbd5e0?text=Guide',
			dialogue: {
				intro: "Welcome, hero! Your journey begins now. This town is your sanctuary. Here's what you should know:<br><br>• <b>Visit the Blacksmith</b> to buy and sell gear.<br>• <b>Visit the Inn</b> to rest and find quests.<br>• <b>Enter the Dungeon</b> when you're ready to fight.",
				level_3: "You're getting stronger! Remember to check your equipment and inventory often. A sharp blade can be the difference between victory and defeat.",
				level_5: "Impressive. At level 5, you can specialize your class. Visit the Inn and speak to the Class Trainer to begin your trial. This is a crucial step in your journey!",
				first_boss: "You feel a powerful presence nearby. Challenging the area's boss is a great way to earn rare rewards, but be sure you are prepared for a tough fight.",
				first_death: "Do not be discouraged by defeat. Every failure is a lesson. Rest at the Inn to recover your strength and try again when you are ready."
			}
		};

        const factions = {
            warrior_gods: { name: 'Warrior Gods', class: 'warrior', rewardItemId: 'legacy_warrior_breastplate', legacyTitle: 'Warrior God', neutralStatBonus: { stat: 'Defense', value: 1 }, reveredAbilityId: 'battle_cry' },
            wizard_gods: { name: 'Wizard Gods', class: 'wizard', rewardItemId: 'legacy_wizard_gloves', legacyTitle: 'Wizard God', neutralStatBonus: { stat: 'Intelligence', value: 1 }, reveredAbilityId: 'daze_enemy' },
            rogue_gods: { name: 'Rogue Gods', class: 'rogue', rewardItemId: 'legacy_rogue_boots', legacyTitle: 'Rogue God', neutralStatBonus: { stat: 'Dexterity', value: 1 }, reveredAbilityId: 'backstab_enemy' },
            fighter_gods: { name: 'Fighter Gods', class: 'fighter', rewardItemId: 'legacy_fighter_pants', legacyTitle: 'Fighter God', neutralStatBonus: { stat: 'Attack', value: 1 }, reveredAbilityId: 'rush_enemy' }
        };

        const reputationTiers = [
            { name: 'Neutral', required: 0 },
            { name: 'Honor', required: 100 },
            { name: 'Revered', required: 250 },
            { name: 'Legacy', required: 500 }
        ];

        const quests = {
            // Forgotten Forest Quests 
            ff_kill_10_monsters: {
                title: "Pest Control",
                description: "Kill 10 monsters of any kind.",
                type: 'kill_any',
                target: 10,
                area: 'forgotten_forest',
                reward: { xp: 100, gold: 25 }
            },
            ff_kill_specific_1: {
                title: "Small Annoyances",
                description: "Kill 3 Snakes, 3 Goblins, and 3 Goblin Shamans Forgotten Forest.",
                type: 'kill_specific',
                targets: { snake: 3, goblin: 3, goblin_shaman: 3 },
                area: 'forgotten_forest',
                reward: { xp: 25, gold: 30 } 
            },
            ff_gather_quest_item_1: {
                title: "WTB: Goblin Blood.",
                description: "The Seller's Post Reads: Looking for goblin blood. The purer the better.",
                type: 'gather_quest_items',
                targets: [
					{ monsterId: 'goblin_warrior', itemId: 'goblin_blood', quantity: 5, dropChance: 0.75 },
					{ monsterId: 'goblin', itemId: 'goblin_blood', quantity: 5, dropChance: 0.45 },
                    { monsterId: 'goblin_shaman', itemId: 'goblin_blood', quantity: 5, dropChance: 0.75 }
				],
                area: 'forgotten_forest', 
                reward: { xp: 90, gold: 25 }
            },
            kill_forgotten_forest_boss: {
                title: "The Chieftain's Challenge",
                description: "The Orc Chieftan must be brought down. I want his head on my mantle.",
                type: 'kill_boss',
                target: 'orc_chieftain',
                area: 'forgotten_forest', 
                reward: { xp: 100, gold: 75, item: 'ff_dragon_key' },
                unlocksOn: ['ff_kill_10_monsters', 'ff_kill_specific_1', 'ff_gather_quest_item_1']
            },
            kill_forgotten_forest_dragon: {
                title: "The Forest Dragon",
                description: "Bring me the head of the forest dragon.",
                type: 'kill_boss',
                target: 'forest_dragon',
                area: 'forgotten_forest', 
                reward: { xp: 100, gold: 75, item: 'map_piece_1' },
                unlocksOn: ['ff_kill_10_monsters', 'ff_kill_specific_1', 'ff_gather_quest_item_1', 'kill_forgotten_forest_boss']
            },
            // Sunken Swamps Quests
            ss_kill_15_monsters: {
                title: "It's starting to smell out there",
                description: "Kill 15 monsters of any kind.",
                type: 'kill_any',
                target: 15,
                area: 'sunken_swamp',
                reward: { xp: 125, gold: 50 }
            },
			ss_gather_slimy_globs: {
				title: "Swamp Cleansing",
				description: "The swamp is overrun with foul creatures. Collect 5 Slimy Globs to help purify the area.",
				type: 'gather_quest_items',
				targets: [
					{ monsterId: 'blobmonster', itemId: 'slimy_glob', quantity: 5, dropChance: 0.75 },
                    { monsterId: 'primordial_ooze', itemId: 'slimy_glob', quantity: 5, dropChance: 0.85 },
					{ monsterId: 'zombie', itemId: 'slimy_glob', quantity: 5, dropChance: 0.25 }
				],
				area: 'sunken_swamp',
				reward: { xp: 150, gold: 100 }
			},
            ss_kill_specific_1: {
                title: "Marsh Death Crew NEEDED!",
                description: "Kill 5 Zombies, 5 Ghouls, and 5 Skeletons in the Sunken Swamps",
                type: 'kill_specific',
                targets: { zombie: 3, ghoul: 3, skeleton: 3 },
                area: 'sunken_swamp',
                reward: { xp: 25, gold: 30 } 
            },
            kill_sunken_swamp_boss: {
                title: "Undead Swamp",
                description: "We are getting reprots of a new type of undead beast. Please check it out",
                type: 'kill_boss',
                target: 'undead_swamp_lizard',
                area: 'sunken_swamp', 
                reward: { xp: 100, gold: 75, item: 'ss_dragon_key' },
                unlocksOn: ['ss_kill_15_monsters', 'ss_gather_slimy_globs', 'ss_kill_specific_1']
            },
            kill_sunken_swamp_dragon: {
                title: "The Swamp Dragon",
                description: "The",
                type: 'kill_boss',
                target: 'swamp_dragon',
                area: 'sunken_swamp', 
                reward: { xp: 100, gold: 75, item: 'map_piece_2' },
                unlocksOn: ['ss_kill_15_monsters', 'ss_gather_slimy_globs', 'ss_kill_specific_1', 'kill_sunken_swamp_boss']
            },
            // Scorched Plains Quests
            sp_kill_20_monsters: {
                title: "It's starting to smell out there",
                description: "Kill 20 monsters of any kind.",
                type: 'kill_any',
                target: 20,
                area: 'scorched_plains',
                reward: { xp: 125, gold: 50 }
            },
			sp_kill_scortched_birds: {
				title: "The Birds Eyes... they shine",
				description: "Their eyes... they shine like suns",
				type: 'kill_specific',
				targets: { pheonix: 5, flock_of_birds: 5, vulture: 5 },
				area: 'scorched_plains',
				reward: { xp: 150, gold: 100 }
			},            
			sp_gather_pheonix_feather: {
				title: "Firey Feathers",
				description: "The pheonix feathers are needed to make all sorts of potions. You got any?",
				type: 'gather_quest_items',
				targets: [
					{ monsterId: 'pheonix', itemId: 'pheonix_feather', quantity: 5, dropChance: 0.75 },
					{ monsterId: 'flock_of_birds', itemId: 'pheonix_feather', quantity: 5, dropChance: 0.25 }
				],
				area: 'scorched_plains',
				reward: { xp: 150, gold: 100 }
			},
            kill_scorched_plains_boss: {
                title: "Elemental Fire",
                description: "Fire is life. Fire can also be death",
                type: 'kill_boss',
                target: 'fire_elemental',
                area: 'scorched_plains', 
                reward: { xp: 100, gold: 75, item: 'sp_dragon_key' },
                unlocksOn: ['sp_kill_20_monsters', 'sp_kill_scortched_birds', 'sp_gather_pheonix_feather']
            },
            kill_scorched_plains_dragon: {
                title: "The Scorched Dragon",
                description: "The dragon has scorched the lands for the last time. Bring me his head",
                type: 'kill_boss',
                target: 'scorched_dragon',
                area: 'scorched_plains', 
                reward: { xp: 100, gold: 75, item: 'map_piece_3' },
                unlocksOn: ['sp_kill_20_monsters', 'sp_kill_scortched_birds', 'sp_gather_pheonix_feather', 'kill_scorched_plains_boss']
            },
            //Frozen Peaks Quests
            fp_kill_25_monsters: {
            title: "Thin the Herd",
            description: "The beasts of the peak are growing too numerous. Kill 25 of them.",
            type: 'kill_any',
            target: 25,
            area: 'frozen_peak',
            reward: { xp: 200, gold: 150 }
        },
        fp_gather_frost_cores: {
			title: "Heart of Ice",
			description: "A local enchanter needs 5 Frost Cores from the Ice Golems that roam the slopes.",
			type: 'gather_quest_items',
			targets: [
				{ monsterId: 'ice_golem', itemId: 'frost_core', quantity: 5, dropChance: 0.5 }
			],
			area: 'frozen_peak',
			reward: { xp: 250, gold: 200 }
		},
        kill_frozen_peak_boss: {
            title: "The Giant Problem",
            description: "An Ice Giant is blocking the path to the summit. It must be removed.",
            type: 'kill_boss',
            target: 'ice_giant',
            area: 'frozen_peak', 
            reward: { xp: 500, gold: 300, item: 'fp_dragon_key' },
            unlocksOn: ['fp_kill_25_monsters', 'fp_gather_frost_cores']
        },
        kill_frozen_peak_dragon: {
            title: "The Frozen Dragon",
            description: "The ancient dragon of the peak has awoken. Defeat it and claim your reward.",
            type: 'kill_boss',
            target: 'frozen_dragon',
            area: 'frozen_peak', 
            reward: { xp: 800, gold: 500, item: 'map_piece_4' },
            unlocksOn: ['kill_frozen_peak_boss']
        },
            //Dragon Wasteland Quests
            //Profession Quests
            blacksmith_basics: {
                title: "Blacksmithing Basics",
                description: "Bring me 5 Iron Ore and I'll teach you how to make a proper sword.",
                type: 'gather_quest_items',
                targets: [
                    { monsterId: 'goblin_warrior', itemId: 'iron_ore', quantity: 2, dropChance: 0.3 },
                    { monsterId: 'goblin_shaman', itemId: 'iron_ore', quantity: 2, dropChance: 0.3 },
                    { monsterId: 'goblin_elder_shaman', itemId: 'iron_ore', quantity: 2, dropChance: 0.3 },
                ],
                area: 'forgotten_forest', 
                reward: { xp: 50, gold: 20, recipe: 'iron_sword_recipe' },
				profession: 'blacksmithing' // <-- Grants the 'iron_sword' recipe
            },
            health_potion_maker: {
                title: "Alchemy: 101",
                description: "Bring me the herbs and I will show you the truth",
                type: 'gather_quest_items',
                targets: [
                    { monsterId: 'goblin', itemId: 'marigold_flower', quantity: 2, dropChance: 0.3 },
                    { monsterId: 'snake', itemId: 'marigold_flower', quantity: 2, dropChance: 0.3 },
                    { monsterId: 'raider', itemId: 'marigold_flower', quantity: 2, dropChance: 0.3 },
                ],
                area: 'forgotten_forest', 
                reward: { xp: 50, gold: 20, recipe: 'simple_healing_potion_recipe' },
				profession: 'herbalism'// <-- Grants the 'simple_healing_potion' recipe
            },
            //Class Quests 
             warrior_trial: {
                title: "Trial of the Warrior: Prove Your Mettle",
                description: "To specialize, you must first prove your strength. Hunt down and defeat 5 Orc Brutes.",
                type: 'kill_specific',
                targets: { orc_brute: 5 },
                area: 'forgotten_forest',
                reward: { xp: 200, gold: 50, item: 'sigil_of_retribution', unlocks: 'subclass' },
                isClassQuest: true
            },
            wizard_trial: {
                title: "Trial of the Wizard: Arcane Attunement",
                description: "To specialize, you must gather magical energies. Collect 5 Frost Cores from Ice Golems.",
                type: 'gather_quest_items',
                targets: [{ monsterId: 'forest_elemental', itemId: 'elemental_core', quantity: 5, dropChance: 0.6 }],
                area: 'forgotten_forest',
                reward: { xp: 200, gold: 50, item: 'relic_of_manaflame', unlocks: 'subclass' },
                isClassQuest: true
            },
            rogue_trial: {
                title: "Trial of the Rogue: A Deft Hand",
                description: "To specialize, show your cunning. Collect a bounty by acquiring 5 Bundles of Wires from the creatures of the Scorched Plains.",
                type: 'gather_quest_items',
                targets: [{ monsterId: 'flock_of_birds', itemId: 'small_electronics', quantity: 5, dropChance: 0.8 }],
                area: 'scorched_plains',
                reward: { xp: 200, gold: 50, item: 'gadget_caltrops', unlocks: 'subclass' },
                isClassQuest: true
            },
            fighter_trial: {
                title: "Trial of the Fighter: The Proving Ground",
                description: "To specialize, you must be versatile. Defeat 10 monsters of any kind in the Sunken Swamp.",
                type: 'kill_any',
                target: 10,
                area: 'sunken_swamp',
                reward: { xp: 200, gold: 50, item: 'medallion_of_valor', unlocks: 'subclass' },
                isClassQuest: true
            }
        };
		
		const areaFinalQuests = {
			forgotten_forest: 'kill_forgotten_forest_dragon',
			sunken_swamp: 'kill_sunken_swamp_dragon',
			scorched_plains: 'kill_scorched_plains_dragon',
            frozen_peak: 'kill_frozen_peak_dragon'
			
		};

        const areas = {
            forgotten_forest: {
                name: 'Forgotten Forest',
                description: 'A dark and ancient forest teeming with goblins and skeletons.',
                background: 'bg-green-900', // Or an image URL
                backgroundTexture: 'bg-forest',
                monsters: ['goblin', 'goblin_warrior', 'goblin_elder_shaman', 'goblin_shaman', 'snake', 'raider', 'orc_brute', 'orc_mage', 'orc_priest', 'forest_elemental'],
                boss: ['orc_chieftain', 'forest_dragon' ]
            },
            sunken_swamp: {
                name: 'Sunken Swamp',
                description: 'A murky swamp home to slimy and undead creatures.',
                background: 'bg-teal-900',
                backgroundTexture: 'bg-swamp',
                monsters: ['ghoul', 'skeleton', 'zombie', 'blobmonster', 'primordial_ooze' ],
                boss: ['undead_swamp_lizard', 'swamp_dragon' ],
                minLevel: 5
            },
            scorched_plains: {
                name: 'Scorched Plains',
                description: 'A dry, cracked wasteland where only the toughest survive.',
                background: 'bg-red-900',
                backgroundTexture: 'bg-plains',
                monsters: ['pheonix', 'flock_of_birds', 'vulture'],
                boss: ['fire_elemental', 'scorched_dragon' ],
                minLevel: 10
            },
            frozen_peak: {
                name: 'Frozen Peak',
                description: 'Icy mountains where frost-bound beasts roam.',
                background: 'bg-blue-900',
                backgroundTexture: 'bg-peak',
                monsters: ['ice_golem', 'yeti'],
                boss: ['ice_giant', 'frozen_dragon'],
                minLevel: 15
            },
            dragon_wastelands: {
                name: 'Dragon Wastelands',
                description: 'Long forgotten about. You need a map to even find it.',
                background: 'bg-gray-900',
                backgroundTexture: 'bg-wasteland',
                monsters: [],
                boss: 'ancestrial_dragon',
                minLevel: 20
            }
        };

        const statExplanations = {
            Health: "Determines your maximum hit points.",
            Mana: "Used to cast powerful abilities.",
            Attack: "Increases the damage of your physical attacks and some abilities.",
            Defense: "Reduces the amount of damage you take from enemy attacks.",
            Dexterity: "Increases your chance to land a critical hit and your chance to successfully run from battle.",
            Intelligence: "Increases the power of your magical abilities.",
            CritChance: "The base probability of your attacks dealing critical damage.",
            CritDamage: "The multiplier for how much extra damage your critical hits deal."
        };
        
        let player = null;
		let currentUser = null;
        let shopInventory = [];
        let currentMonster = null;
        let dungeonFloor = 1;

        // --- DOM ELEMENTS ---
        const characterSelectionScreen = document.getElementById('character-selection-screen');
        const townScreen = document.getElementById('town-screen');
        const shopScreen = document.getElementById('shop-screen');
        const dungeonScreen = document.getElementById('dungeon-screen');
        const innScreen = document.getElementById('inn-screen');
        const subclassSelectionScreen = document.getElementById('subclass-selection-screen');
        const questBoardScreen = document.getElementById('quest-board-screen');
        const mapScreen = document.getElementById('map-screen'); // <-- Open Map Button
        const gameLog = document.getElementById('game-log');
        const tooltip = document.getElementById('tooltip'); // Tool tip 
        const visitblacksmithshopBtn = document.getElementById('visit-blacksmithshop'); //blacksmithshop button
        const enterDungeonBtn = document.getElementById('enter-dungeon'); // Enter Dungeon Button
        const challengeBossBtn = document.getElementById('challenge-boss');
        const leaveShopBtn = document.getElementById('leave-shop');
        const playerImage = document.getElementById('player-image');
        const attackBtn = document.getElementById('attack-btn');
        const itemsBtn = document.getElementById('items-btn');
        const runBtn = document.getElementById('run-btn');
        const returnToTownBtn = document.getElementById('return-to-town-btn');
        const nextFloorBtn = document.getElementById('next-floor-btn');
        const visitInnBtn = document.getElementById('visit-inn');
        const leaveInnBtn = document.getElementById('leave-inn-btn');
        const innRestBtn = document.getElementById('inn-rest-btn');
        const innReputationBtn = document.getElementById('inn-reputation-btn');
        const innTrainBtn = document.getElementById('inn-train-btn');
        const innQuestBtn = document.getElementById('inn-quest-btn');
        const returnToInnBtn = document.getElementById('return-to-inn-btn');
        const questReturnToInnBtn = document.getElementById('quest-return-to-inn-btn');
        const loadGameBtn = document.getElementById('load-game-btn');
        const saveGameBtn = document.getElementById('save-game-btn');
        const mainMenuBtn = document.getElementById('main-menu-btn');
		const achievementScreen = document.getElementById('achievement-screen');
        const dialogueModal = document.getElementById('dialogue-modal');
		const bankScreen = document.getElementById('bank-screen');
		const visitBankBtn = document.getElementById('visit-bank');
		const leaveBankBtn = document.getElementById('leave-bank-btn');
		const buyBankSlotBtn = document.getElementById('buy-bank-slot-btn');
		const guideModal = document.getElementById('guide-modal');
		const guideCloseBtn = document.getElementById('guide-close-btn');
		const authScreen = document.getElementById('auth-screen');
		const loginBtn = document.getElementById('login-btn');
		const signupBtn = document.getElementById('signup-btn');
		const alphaGateScreen = document.getElementById('alpha-gate-screen');



        // --- FUNCTIONS ---
		
		// --- START: NEW AUTHENTICATION FUNCTIONS ---

		function handleSignUp() {
			const email = document.getElementById('email').value;
			const password = document.getElementById('password').value;
			if (!email || password.length < 6) {
				logMessage("Please enter a valid email and a password of at least 6 characters.", "text-red-400");
				return;
			}
			auth.createUserWithEmailAndPassword(email, password)
				.then(userCredential => {
					logMessage(`Account created for ${userCredential.user.email}!`, "text-green-400");
					// The onAuthStateChanged listener will handle showing the character screen.
				})
				.catch(error => {
					logMessage(error.message, "text-red-400");
				});
		}

		function handleLogin() {
			const email = document.getElementById('email').value;
			const password = document.getElementById('password').value;
			auth.signInWithEmailAndPassword(email, password)
				.catch(error => {
					logMessage(error.message, "text-red-400");
				});
		}

		function handleLogout() {
			auth.signOut().then(() => {
				window.location.reload();
			});
		}

		// --- END: NEW AUTHENTICATION FUNCTIONS ---
		
		function checkAlphaCode() {
			const enteredCode = document.getElementById('alpha-code').value;
			if (!enteredCode) {
				logMessage("Please enter an invite code.", "text-red-400");
				return;
			}

			// Ask the database for the correct code
			db.collection('config').get().then(querySnapshot => {
				let isValid = false;
				querySnapshot.forEach(doc => {
					// Check if the entered code matches the one in the database
					if (doc.data().inviteCode === enteredCode) {
						isValid = true;
					}
				});

				if (isValid) {
					alphaGateScreen.classList.add('hidden');
					authScreen.classList.remove('hidden'); // Show the real login screen
				} else {
					logMessage("Incorrect invite code.", "text-red-400");
				}
			}).catch(error => {
				logMessage("Error checking code: " + error.message, "text-red-400");
			});
		}
        function logMessage(message, color = 'text-gray-300') {
            const logEntry = document.createElement('p');
            logEntry.className = color;
            logEntry.innerHTML = `> ${message}`; 
            gameLog.appendChild(logEntry);
            gameLog.scrollTop = gameLog.scrollHeight;
        }
	

        function updateBackground(areaId) {
            const allTextures = Object.values(areas).map(area => area.backgroundTexture);
            document.body.classList.remove(...allTextures); // Remove any existing textures
            
            const newTexture = areas[areaId]?.backgroundTexture;
            if (newTexture) {
                document.body.classList.add(newTexture); // Add the new one
            } else {
                // Optional: Fallback to the default if no texture is found
                document.body.classList.add('bg-gray-900');
            }
        }

        function addSimpleTooltip(element, text) {
            element.addEventListener('mousemove', (e) => {
                tooltip.innerHTML = `<p>${text}</p>`;
                tooltip.style.left = `${e.pageX + 15}px`;
                tooltip.style.top = `${e.pageY + 15}px`;
                tooltip.classList.remove('hidden');
            });
            element.addEventListener('mouseleave', () => tooltip.classList.add('hidden'));
        }
		
		// --- START: NEW GUIDE FUNCTIONS ---

		/**
		 * Shows a piece of advice from the guide NPC if it hasn't been seen before.
		 * @param {string} messageKey - The key of the dialogue to show (e.g., 'intro', 'level_5').
		 */
		function showGuideModal(messageKey) {
			if (!guideNPC.dialogue[messageKey] || player.seenGuideMessages.includes(messageKey)) {
				return; // Don't show if message doesn't exist or has been seen
			}

			document.getElementById('guide-npc-image').src = guideNPC.image;
			document.getElementById('guide-npc-name').textContent = guideNPC.name;
			// This is the line that has been changed
			document.getElementById('guide-npc-text').innerHTML = guideNPC.dialogue[messageKey];
			
			guideModal.classList.remove('hidden');
			
			// Mark this message as seen
			player.seenGuideMessages.push(messageKey);
		}

		/**
		 * Hides the guide's dialogue modal.
		 */
		function hideGuideModal() {
			guideModal.classList.add('hidden');
		}

		/**
		 * Checks the player's status to see if any new guide advice should be triggered.
		 */
		function checkGuideTriggers() {
			if (player.level >= 3) {
				showGuideModal('level_3');
			}
			if (player.level >= 5) {
				showGuideModal('level_5');
			}
			// Add more triggers here as the game grows
		}

		// --- END: NEW GUIDE FUNCTIONS ---

        function hideDialogueModal() {
            dialogueModal.classList.add('hidden');
        }

        function showDialogueModal(npc, actions) {
			const dialogueText = getNpcDialogue(npc); 

			document.getElementById('dialogue-npc-image').src = npc.image;
			document.getElementById('dialogue-npc-name').textContent = npc.name;
			// This is the line that has been changed
			document.getElementById('dialogue-npc-text').innerHTML = dialogueText;

			const actionsContainer = document.getElementById('dialogue-actions');
			actionsContainer.innerHTML = '<button id="dialogue-close-btn" class="bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg">Leave</button>';
			
			actions.forEach(action => {
				const button = document.createElement('button');
				button.className = 'bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded-lg';
				button.textContent = action.label;
				button.onclick = () => {
					hideDialogueModal();
					action.callback();
				};
				actionsContainer.insertBefore(button, actionsContainer.firstChild);
			});

			document.getElementById('dialogue-close-btn').onclick = hideDialogueModal;
			dialogueModal.classList.remove('hidden');
		}

        function addTooltipEvents(element, item) {
            element.addEventListener('mousemove', (e) => {
                const rarityInfo = rarities[item.rarity];
                let statsHtml = '';
                if (item.stats) {
                    for (const [stat, value] of Object.entries(item.stats)) {
                        statsHtml += `<p class="text-green-400">+${value} ${stat}</p>`;
                    }
                }
                let descriptionHtml = item.description ? `<p class="text-gray-400 mt-1">${item.description}</p>` : '';

                //Set Bonus Display Logic
                let setBonusHtml = '';
                // Check if the item is part of a set AND if that set's bonus is active on the player.
                if (item.set && player.activeSetBonuses[item.set]) {
                    const activeBonus = player.activeSetBonuses[item.set];
                    // Create the HTML string for the bonus description.
                    setBonusHtml = `<p class="text-purple-400 mt-2 font-semibold">Set Bonus: ${activeBonus.description}</p>`;
                }

                let requirementsHtml = '';
                if (item.requirements) {
                    if (item.requirements.level) {
                        requirementsHtml += `<p class="mt-1 ${player.level < item.requirements.level ? 'text-red-400' : 'text-gray-400'}">Requires Level ${item.requirements.level}</p>`;
                    }
                    if (item.requirements.class) {
                        requirementsHtml += `<p class="${player.classId !== item.requirements.class ? 'text-red-400' : 'text-gray-400'}">Requires: ${classes[item.requirements.class].name}</p>`;
                    }
                }
                
                // Add the new setBonusHtml to the final tooltip output.
                tooltip.innerHTML = `<h4 class="font-bold ${rarityInfo.textColor}">${item.name}</h4><p class="text-xs ${rarityInfo.textColor} -mt-1 mb-1">${rarityInfo.name}</p>${statsHtml}${descriptionHtml}${setBonusHtml}${requirementsHtml}`;
                
                tooltip.style.left = `${e.pageX + 15}px`;
                tooltip.style.top = `${e.pageY + 15}px`;
                tooltip.classList.remove('hidden');
            });
            element.addEventListener('mouseleave', () => tooltip.classList.add('hidden'));
        }
		
		function enterBank() {
			townScreen.classList.add('hidden');
			bankScreen.classList.remove('hidden');
			updateBankUI();
		}

		/**
		 * Hides the bank screen and shows the town screen.
		 */
		function exitBank() {
			bankScreen.classList.add('hidden');
			townScreen.classList.remove('hidden');
			updatePlayerDisplay(); // Refresh the main inventory display
		}

		/**
		 * Renders the player's inventory and bank slots in the bank UI.
		 */
		function updateBankUI() {
			if (!player) return;

			document.getElementById('bank-player-gold').textContent = player.gold;
			const inventoryContainer = document.getElementById('bank-inventory-slots');
			const bankContainer = document.getElementById('bank-storage-slots');
			inventoryContainer.innerHTML = '';
			bankContainer.innerHTML = '';

			// Render Player Inventory
			player.inventory.forEach((slotData, index) => {
				const slotEl = createSlotElement(slotData);
				if (slotData.item) {
					slotEl.onclick = () => depositItem(index);
				}
				inventoryContainer.appendChild(slotEl);
			});

			// Render Bank Slots
			player.bank.forEach((slotData, index) => {
				const slotEl = createSlotElement(slotData);
				 if (slotData.item) {
					slotEl.onclick = () => withdrawItem(index);
				}
				bankContainer.appendChild(slotEl);
			});
		}

		/**
		 * Helper function to create a single item slot element for UI.
		 * @param {object} slotData - The slot object containing item and quantity.
		 * @returns {HTMLElement} The created slot element.
		 */
		function createSlotElement(slotData) {
			const slotEl = document.createElement('div');
			slotEl.className = 'slot bg-gray-900 rounded-md flex items-center justify-center';
			
			if (slotData.item) {
				const item = slotData.item;
				const rarityInfo = rarities[item.rarity];
				
				let iconHtml = '';
				if (item.icon && item.icon.endsWith('.png')) {
					iconHtml = `<img src="${item.icon}" alt="${item.name}" class="w-10 h-10 object-contain">`;
				} else {
					iconHtml = `<div class="text-2xl">${item.icon}</div>`;
				}
				slotEl.innerHTML = iconHtml;

				slotEl.classList.remove('bg-gray-900');
				slotEl.classList.add(rarityInfo.color, rarityInfo.borderColor);
				addTooltipEvents(slotEl, item);

				if (slotData.quantity > 1) {
					const quantityEl = document.createElement('div');
					quantityEl.className = 'absolute bottom-1 right-1 bg-gray-900 text-white text-xs font-bold rounded px-1';
					quantityEl.textContent = slotData.quantity;
					slotEl.appendChild(quantityEl);
				}
			}
			return slotEl;
		}

		/**
		 * Moves an item from the player's inventory to their bank.
		 * @param {number} inventoryIndex - The index of the item in the inventory.
		 */
		function depositItem(inventoryIndex) {
			const slotToMove = player.inventory[inventoryIndex];
			if (!slotToMove.item) return;

			const emptyBankSlot = player.bank.find(slot => !slot.item);
			if (emptyBankSlot) {
				// Move item data
				emptyBankSlot.item = slotToMove.item;
				emptyBankSlot.quantity = slotToMove.quantity;
				
				// Clear original inventory slot
				slotToMove.item = null;
				slotToMove.quantity = 0;
				
				logMessage(`Deposited ${emptyBankSlot.item.name}.`, 'text-yellow-400');
				updateBankUI();
			} else {
				logMessage("Your bank is full!", "text-red-400");
			}
		}

		/**
		 * Moves an item from the bank to the player's inventory.
		 * @param {number} bankIndex - The index of the item in the bank.
		 */
		function withdrawItem(bankIndex) {
			const slotToMove = player.bank[bankIndex];
			if (!slotToMove.item) return;

			const emptyInventorySlot = player.inventory.find(slot => !slot.item);
			if(emptyInventorySlot) {
				// Move item data
				emptyInventorySlot.item = slotToMove.item;
				emptyInventorySlot.quantity = slotToMove.quantity;

				// Clear original bank slot
				slotToMove.item = null;
				slotToMove.quantity = 0;

				logMessage(`Withdrew ${emptyInventorySlot.item.name}.`, 'text-green-400');
				updateBankUI();
			} else {
				logMessage("Your inventory is full!", "text-red-400");
			}
		}

		/**
		 * Handles the logic for purchasing a new bank slot.
		 */
		function buyBankSlot() {
			const cost = 400;
			if (player.gold < cost) {
				logMessage("You don't have enough gold to buy a new bank slot.", "text-red-400");
				return;
			}

			player.gold -= cost;
			player.bankSlots++;
			player.bank.push({ item: null, quantity: 0 });

			logMessage(`You purchased a new bank slot for ${cost} gold!`, 'text-green-400');
			updateBankUI();
		}

		
        function getNpcDialogue(npc) { // Changed parameter name for clarity
            // This function now ONLY handles the one-time introduction modal.
            if (!player.dialogueInteractions) {
                player.dialogueInteractions = {};
            }
            
            // Mark the intro as "seen" by setting the state to 0.
            // This happens when the intro modal is first opened.
            player.dialogueInteractions[npc.name] = 0; // Use the unique NPC name as a key
            
            // Always return the intro text from the object that was passed in.
            return npc.dialogue.intro; // CORRECTED LINE
        }

        function getNpcAreaDialogue(npc) { // Changed parameter name for clarity
            // This function provides the non-modal dialogue for subsequent visits.
            if (!player.dialogueInteractions) player.dialogueInteractions = {};
            
            const npcDialogues = npc.dialogue; // CORRECTED: Use the passed object directly
            const lastLevelShown = player.dialogueInteractions[npc.name] || 0; // CORRECTED: Use the NPC's name as the key

            let highestNewLevel = 0;
            let newDialogue = null;

            // Find the best new dialogue the player qualifies for but hasn't seen.
            for (const key in npcDialogues) {
                if (key.startsWith('level_')) {
                    const levelRequirement = parseInt(key.split('_')[1]);
                    if (player.level >= levelRequirement && levelRequirement > lastLevelShown && levelRequirement > highestNewLevel) {
                        highestNewLevel = levelRequirement;
                        newDialogue = npcDialogues[key];
                    }
                }
            }

            // If we found a new level-up dialogue, update the player's state and show it.
            if (newDialogue) {
                player.dialogueInteractions[npc.name] = highestNewLevel; // CORRECTED: Use the NPC's name as the key
                return newDialogue;
            } else {
                // No new dialogue, return a generic message based on the NPC's name.
                // This switch statement has been fixed to check the name from the object.
                switch(npc.name) {
                    case 'Grumble Ironhand':
                    case 'Mirella Rust-Eater':
                    case 'Anvil Rustgut':
                    case 'Granite Coldfist':
                    case 'Wasteland Scavenger':
                        return "Finest weapons and armor.";
                    case 'The Emissary':
                    case 'Whisper in the Reeds':
                    case 'Axes Sootbeard':
                    case 'Mountian Village Gods Trainer':
                    case 'Echo of the First Wyrm':
                        return "The gods are always watching.";
                    case 'Seraphina':
                    case 'Old Man Willow':
                    case 'Plains General':
                    case 'Mountian Village Chief':
                    case 'Ancient Chronicler':
                        return "Story and Profession Quests are listed seperately. Make sure to check them both out.";
                    default:
                        return "I have nothing new for you right now.";
                }
            }
        }
        
        function handleClassTrainerInteraction() {
            const trainer = npcs[player.currentArea]?.classTrainer;
            if (!trainer) return;

            if (player.level < 5) {
                showDialogueModal(trainer, []); 
                document.getElementById('dialogue-npc-text').textContent = "You are not yet strong enough. Return when you have reached level 5.";
                return;
            }

            const classQuests = {
                warrior: 'warrior_trial',
                wizard: 'wizard_trial',
                rogue: 'rogue_trial',
                fighter: 'fighter_trial'
            };

            const questId = classQuests[player.classId];
            const quest = quests[questId];
            const playerQuest = player.quests[questId];

            let dialogueText = trainer.dialogue.intro;
            let actions = [];

            if (playerQuest.isTurnedIn) {
                dialogueText = "You have already proven yourself and chosen your path.";
            } else if (playerQuest.isComplete) {
                dialogeText = "I see you have completed your trial! Well done. Claim your reward.";
                actions.push({ label: 'Complete Trial', callback: () => {
                    hideDialogueModal();
                    turnInQuest(questId); 
                }});
            } else if (playerQuest.isAccepted) {
                dialogueText = "Your trial is underway. Return when you have completed it.";
            } else { 
                dialogueText = `To proceed, you must complete a trial. ${quest.description}`;
                actions.push({ label: 'Accept Trial', callback: () => {
                    acceptQuest(questId);
                    hideDialogueModal();
                }});
            }

            showDialogueModal(trainer, actions);
            if (dialogueText !== trainer.dialogue.intro) {
                 document.getElementById('dialogue-npc-text').textContent = dialogueText;
            }
        }

		function unlockAchievement(achievementId) {
			// Check if the achievement is already unlocked or claimed
			if (player.achievements.unlocked.includes(achievementId) || player.achievements.claimed.includes(achievementId)) {
				return; // Already done, do nothing
			}

			// Unlock it
			player.achievements.unlocked.push(achievementId);
			const achievement = achievements[achievementId];
			logMessage(`New achievement available to claim: ${achievement.name}!`, 'text-purple-400');
		}

		function claimAchievement(achievementId) {
			// Make sure it's unlocked and not already claimed
			if (!player.achievements.unlocked.includes(achievementId) || player.achievements.claimed.includes(achievementId)) {
				return;
			}

			// Grant rewards
			const achievement = achievements[achievementId];
			player.achievements.totalPoints += achievement.points;

			// Move from unlocked to claimed
			player.achievements.unlocked = player.achievements.unlocked.filter(id => id !== achievementId);
			player.achievements.claimed.push(achievementId);

			logMessage(`Claimed ${achievement.points} achievement points for "${achievement.name}"!`, 'text-yellow-400');

			// Refresh the UI
			updateAchievementsUI();
		}

		function updateAchievementsUI() {
			const container = document.getElementById('achievement-container');
			container.innerHTML = '';
			document.getElementById('achievement-points').textContent = player.achievements.totalPoints;

			for (const id in achievements) {
				const achievement = achievements[id];
				const el = document.createElement('div');
				let statusHtml = '';
				let bgColor = 'bg-gray-800';

				if (player.achievements.claimed.includes(id)) {
					statusHtml = `<div class="text-green-400 font-bold">Claimed</div>`;
					bgColor = 'bg-green-900/30';
				} else if (player.achievements.unlocked.includes(id)) {
					statusHtml = `<button class="collect-achievement-btn bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded" data-id="${id}">Collect</button>`;
					bgColor = 'bg-yellow-900/30';
				} else {
					statusHtml = `<div class="text-gray-500 font-bold">Locked</div>`;
				}

				el.className = `flex items-center justify-between p-4 rounded-lg ${bgColor}`;
				el.innerHTML = `
					<div class="flex items-center">
						<div class="text-4xl mr-4">${achievement.icon}</div>
						<div>
							<h4 class="text-lg font-bold">${achievement.name}</h4>
							<p class="text-sm text-gray-400">${achievement.description}</p>
							<p class="text-xs text-yellow-300">Points: ${achievement.points}</p>
						</div>
					</div>
					<div>${statusHtml}</div>
				`;
				container.appendChild(el);
			}

			document.querySelectorAll('.collect-achievement-btn').forEach(btn => {
				btn.onclick = (e) => claimAchievement(e.target.dataset.id);
			});
		}

		function showAchievementsScreen() {
			townScreen.classList.add('hidden');
			achievementScreen.classList.remove('hidden');
			updateAchievementsUI();
		}

        function updatePlayerDisplay() {
			if (!player) return;
			playerImage.src = player.image;
			document.getElementById('player-name').textContent = player.subclass ? `${player.name} (${subclasses[player.classId][player.subclass].name})` : player.name;
			document.getElementById('player-level').textContent = player.level;
			document.getElementById('player-gold').textContent = player.gold;

			document.getElementById('player-xp').textContent = player.xp;
			document.getElementById('player-xp-needed').textContent = player.xpNeeded;
			document.getElementById('player-xp-bar').style.width = `${(player.xp / player.xpNeeded) * 100}%`;

			const shopGoldEl = document.getElementById('shop-player-gold');
			if (shopGoldEl) shopGoldEl.textContent = player.gold;
			
			document.getElementById('town-player-hp').textContent = player.currentHealth;
			document.getElementById('town-player-max-hp').textContent = player.stats.Health;
			document.getElementById('town-player-health-bar').style.width = `${(player.currentHealth / player.stats.Health) * 100}%`;

			document.getElementById('town-player-mana').textContent = player.currentMana;
			document.getElementById('town-player-max-mana').textContent = player.stats.Mana;
			document.getElementById('town-player-mana-bar').style.width = `${(player.currentMana / player.stats.Mana) * 100}%`;

			const statsContainer = document.getElementById('player-stats');
			statsContainer.innerHTML = '';
			for (const [stat, value] of Object.entries(player.stats)) {
				const statEl = document.createElement('div');
				statEl.className = 'bg-gray-800 p-2 rounded-md text-center';
				let displayValue = value;
				if (stat === 'CritChance') {
					const totalCritChance = value + (player.stats.Dexterity / 200);
					displayValue = `${(totalCritChance * 100).toFixed(1)}%`;
				} else if (stat === 'CritDamage') {
					displayValue = `${value}x`;
				}
				statEl.innerHTML = `<p class="text-sm text-gray-400">${stat}</p><p class="font-bold text-lg">${displayValue}</p>`;
				if (statExplanations[stat]) {
					addSimpleTooltip(statEl, statExplanations[stat]);
				}
				statsContainer.appendChild(statEl);
			}

			const abilitiesContainer = document.getElementById('player-abilities-list');
			abilitiesContainer.innerHTML = '';
			player.abilities.forEach(abilityId => {
				const ability = abilities[abilityId];
				const abilityEl = document.createElement('div');
				abilityEl.className = 'bg-gray-800 p-3 rounded-lg';
				abilityEl.innerHTML = `<p class="font-bold text-white">${ability.name} (${ability.manaCost} Mana)</p><p class="text-sm text-gray-400">${ability.description}</p>`;
				abilitiesContainer.appendChild(abilityEl);
			});

			for(const slot in player.equipment) {
				const slotEl = document.getElementById(`slot-${slot}`);
				if (!slotEl) continue; // Failsafe for slots that don't have a UI element

				slotEl.onclick = () => unequipItem(slot);
				const item = player.equipment[slot];
				const rarityClasses = Object.values(rarities).flatMap(r => [r.color, r.borderColor]);
				slotEl.classList.remove(...rarityClasses);
				slotEl.classList.add('bg-gray-900');

				if (item) {
					const rarityInfo = rarities[item.rarity];
					let iconHtml = '';
                    if (item.icon && item.icon.endsWith('.png')) {
                        // If it's a PNG, create an <img> tag
                        iconHtml = `<img src="${item.icon}" alt="${item.name}" class="w-10 h-10 object-contain">`;
                    } else {
                        // Otherwise, it's an emoji, so use the old div
                        iconHtml = `<div class="text-2xl">${item.icon}</div>`;
                    }
                    slotEl.innerHTML = iconHtml;;
					slotEl.classList.remove('text-gray-500', 'bg-gray-900');
					slotEl.classList.add(rarityInfo.color, rarityInfo.borderColor);
					addTooltipEvents(slotEl, item);
				} else {
					// Capitalize slot name for display
					const slotName = slot.charAt(0).toUpperCase() + slot.slice(1);
					slotEl.innerHTML = slotName === 'Offhand' ? 'Off-Hand' : slotName;
					slotEl.classList.add('text-gray-500');
					slotEl.onclick = null;
				}
			}

			// LOGIC FOR TWO-HANDED WEAPON VISUALS
			const offhandSlotEl = document.getElementById('slot-offhand');
			const mainWeapon = player.equipment.weapon;
			if (mainWeapon && mainWeapon.hand === 'two') {
				offhandSlotEl.innerHTML = '<span class="text-red-500 text-4xl">X</span>';
				offhandSlotEl.onclick = null;
				offhandSlotEl.classList.add('cursor-not-allowed');
			} else {
				offhandSlotEl.classList.remove('cursor-not-allowed');
			}

			const inventoryContainer = document.getElementById('inventory-slots');
			inventoryContainer.innerHTML = '';
			player.inventory.forEach((slotData, index) => {
				const slotEl = document.createElement('div');
				slotEl.className = 'slot bg-gray-900 rounded-md flex items-center justify-center';
				if (slotData.item) {
					const item = slotData.item;
					const rarityInfo = rarities[item.rarity];
					
                    // --- START: Corrected Code ---
                    let iconHtml = '';
                    if (item.icon && item.icon.endsWith('.png')) {
                        // If it's a PNG, create an <img> tag
                        iconHtml = `<img src="${item.icon}" alt="${item.name}" class="w-10 h-10 object-contain">`;
                    } else {
                        // Otherwise, it's an emoji, so wrap it in a div
                        iconHtml = `<div class="text-2xl">${item.icon}</div>`;
                    }
                    slotEl.innerHTML = iconHtml;
                    // --- END: Corrected Code ---

					slotEl.classList.remove('bg-gray-900');
					slotEl.classList.add(rarityInfo.color, rarityInfo.borderColor);
		            addTooltipEvents(slotEl, item);

					if (slotData.quantity > 1) {
						const quantityEl = document.createElement('div');
						quantityEl.className = 'absolute bottom-1 right-1 bg-gray-900 text-white text-xs font-bold rounded px-1';
						quantityEl.textContent = slotData.quantity;
						slotEl.appendChild(quantityEl);
					}

					if (item.type === 'consumable') {
						slotEl.onclick = () => useItem(index);
					} else if (item.type !== 'junk') {
						slotEl.onclick = () => equipItem(index);
					} else {
						slotEl.onclick = null;
					}
				} else {
					slotEl.onclick = null;
				}
				inventoryContainer.appendChild(slotEl);
			});

			// --- NEW LOGIC TO UPDATE BOSS BUTTON TEXT ---
			const challengeBossBtn = document.getElementById('challenge-boss');
			const finalQuestId = areaFinalQuests[player.currentArea];

			// Check if there is a final quest for the current area and if the player has accepted it
			if (finalQuestId && player.quests[finalQuestId]?.isAccepted && !player.quests[finalQuestId]?.isTurnedIn) {
				// Change the button's content for the final dragon quest
				challengeBossBtn.innerHTML = `<div class="text-4xl mb-2">🐉</div><h3 class="text-xl font-bold">Defeat Area Dragon</h3>`;
			} else {
				// Revert to the default content
				challengeBossBtn.innerHTML = `<div class="text-4xl mb-2">👑</div><h3 class="text-xl font-bold">Challenge the Boss</h3>`;
			}
		}
        
        function levelUp() {
            while (player.xp >= player.xpNeeded) {
                player.level++;
                player.xp -= player.xpNeeded;
                player.xpNeeded = player.level * 100;

                // Check for level achievements
                Object.keys(achievements).forEach(id => {
                    const achievement = achievements[id];
                    if (achievement.type === 'level' && player.level >= achievement.value) {
                        unlockAchievement(id);
                    }
                });

                const statIncreases = { Health: 10, Mana: 5, Attack: 2, Defense: 1, Dexterity: 1, Intelligence: 1 };
                for (const [stat, increase] of Object.entries(statIncreases)) {
                    player.stats[stat] += increase;
                }

                player.currentHealth = player.stats.Health;
                player.currentMana = player.stats.Mana;

                logMessage(`Ding! You reached Level ${player.level}! Your stats have increased!`, 'text-yellow-400');

                // Check for base class abilities
                for (const [abilityId, abilityData] of Object.entries(abilities)) {
                    if (abilityData.class === player.classId && abilityData.level === player.level) {
                        player.abilities.push(abilityId);
                        logMessage(`You learned a new ability: ${abilityData.name}!`, 'text-purple-400');
                    }
                }
                
                // Check for subclass abilities
                if (player.subclass) {
                    const subclassAbilities = subclasses[player.classId][player.subclass].abilities;
                    subclassAbilities.forEach(abilityId => {
                        const abilityData = abilities[abilityId];
                        if (abilityData.level === player.level) {
                             player.abilities.push(abilityId);
                             logMessage(`As a ${subclasses[player.classId][player.subclass].name}, you learned: ${abilityData.name}!`, 'text-purple-400');
                        }
                    });
                }
            }
			checkGuideTriggers();
        }

        function initializeClassSelection() {
            const selectionContainer = document.getElementById('class-selection-container');
            selectionContainer.innerHTML = '';
            for (const [id, classData] of Object.entries(classes)) {
                const card = document.createElement('div');
                card.className = 'class-card bg-gray-700 p-6 rounded-xl text-center cursor-pointer';
                card.innerHTML = `<div class="text-4xl mb-4">${classData.icon}</div>
                                <h3 class="text-xl font-bold mb-2">${classData.name}</h3>
                                <p class="text-sm text-gray-400">${classData.description}</p>`;
                card.onclick = () => selectClass(id);
                selectionContainer.appendChild(card);
            }
        }
        
        function addItemToInventory(itemToAdd) {
            const maxStack = 5;
            
            if (itemToAdd.stackable) {
                for (const slot of player.inventory) {
                    if (slot.item && slot.item.name === itemToAdd.name && slot.quantity < maxStack) {
                        slot.quantity++;
                        logMessage(`Added ${itemToAdd.name} to your inventory (now x${slot.quantity}).`);
                        updatePlayerDisplay();
                        return true; 
                    }
                }
            }

            const emptySlot = player.inventory.find(slot => slot.item === null);
            if (emptySlot) {
                emptySlot.item = itemToAdd;
                emptySlot.quantity = 1;
                logMessage(`You found: ${itemToAdd.name}!`);
                updatePlayerDisplay();
                return true;
            } else {
                logMessage("Your inventory is full!", "text-red-400");
                return false;
            }
        }

        function useItem(inventoryIndex) {
            const slot = player.inventory[inventoryIndex];
            if (!slot.item || slot.item.type !== 'consumable') return;
            const item = slot.item;

            switch(item.effect.type) {
                case 'heal':
                    player.currentHealth = Math.min(player.stats.Health, player.currentHealth + item.effect.amount);
                    logMessage(`You used a ${item.name} and restored ${item.effect.amount} health.`, 'text-green-400');
                    break;
                case 'mana_heal':
                    player.currentMana = Math.min(player.stats.Mana, player.currentMana + item.effect.amount);
                    logMessage(`You used a ${item.name} and restored ${item.effect.amount} mana.`, 'text-blue-400');
                    break;
                case 'temp_buff':
                    player.tempBuffs.push(item.effect);
                    logMessage(`You used a ${item.name}. Your ${item.effect.stat} will be boosted in the next fight!`, 'text-yellow-400');
                    break;
            }
            
            slot.quantity--;
            if (slot.quantity <= 0) {
                slot.item = null;
                slot.quantity = 0;
            }
            updatePlayerDisplay();
        }

        function equipItem(inventoryIndex) {
            const slotData = player.inventory[inventoryIndex];
            if (!slotData.item) return;
            const item = slotData.item;

            // Requirement checks (level, class) remain the same
            if (item.requirements) {
                if (item.requirements.level && player.level < item.requirements.level) {
                    logMessage(`You must be level ${item.requirements.level} to equip this item.`, 'text-red-400');
                    return;
                }
                if (item.requirements.class && player.classId !== item.requirements.class) {
                    logMessage(`Only a ${classes[item.requirements.class].name} can equip this item.`, 'text-red-400');
                    return;
                }
            }

            // NEW LOGIC FOR WEAPONS
            if (item.type === 'weapon') {
                const mainHand = player.equipment.weapon;
                const offHand = player.equipment.offhand;

                if (item.hand === 'two') {
                    // Cannot equip a two-handed weapon if any hand is full
                    if (mainHand || offHand) {
                        logMessage('You must have both hands free to equip a two-handed weapon.', 'text-red-400');
                        return;
                    }
                    // Equip in main hand, off-hand will be blocked by UI function
                    player.equipment.weapon = item;

                } else if (item.hand === 'one') {
                    // Cannot equip a one-handed weapon if a two-handed is equipped
                    if (mainHand && mainHand.hand === 'two') {
                        logMessage('You cannot equip another weapon while using a two-handed weapon.', 'text-red-400');
                        return;
                    }
                    
                    // Equip in main hand if empty, otherwise try off-hand
                    if (!mainHand) {
                        player.equipment.weapon = item;
                    } else if (!offHand) {
                        player.equipment.offhand = item;
                    } else {
                        // If both hands are full, replace the main hand weapon
                        unequipItem('weapon'); // Unequip and add stats back correctly
                        player.equipment.weapon = item;
                    }
                }
                // Remove item from inventory
                slotData.item = null; 
                slotData.quantity = 0;

            } else { // EQUIP ARMOR LOGIC
                const targetSlot = item.slot;
                const currentlyEquipped = player.equipment[targetSlot];

                if (currentlyEquipped) {
                    for (const [stat, value] of Object.entries(currentlyEquipped.stats)) {
                        player.stats[stat] -= value;
                    }
                }

                player.equipment[targetSlot] = item;
                slotData.item = currentlyEquipped || null;
                slotData.quantity = currentlyEquipped ? 1 : 0;
            }

            // Add stats of the newly equipped item
            for (const [stat, value] of Object.entries(item.stats)) {
                player.stats[stat] += value;
            }
            logMessage(`Equipped ${item.name}.`);
            updatePlayerDisplay();
            updateSetBonuses();
        }

        function unequipItem(slot) {
            const item = player.equipment[slot];
            if (!item) return;
            
            if (addItemToInventory(item)) {
                for (const [stat, value] of Object.entries(item.stats)) {
                    player.stats[stat] -= value;
                }
                player.equipment[slot] = null;
                logMessage(`Unequipped ${item.name}.`);
                updatePlayerDisplay();
                updateSetBonuses();
            }
        }

        function selectClass(classId) {
            // Create a fresh player object for the selected class
            const selectedClass = classes[classId];
            player = {
                name: selectedClass.name,
                classId: classId,
                subclass: null,
                level: 1,
                xp: 0,
                xpNeeded: 100,
                currentArea: 'forgotten_forest',
                gold: Math.floor(Math.random() * 31) + 20,
                currentHealth: selectedClass.stats.Health,
                currentMana: selectedClass.stats.Mana,
                stats: { ...selectedClass.stats }, // Make sure stats for calculations
                equipment: { head: null, chest: null, gloves: null, legs: null, boots: null, weapon: null, offhand: null, special: null },
                inventory: new Array(10).fill(null).map(() => ({ item: null, quantity: 0 })),
                bank: new Array(10).fill(null).map(() => ({ item: null, quantity: 0 })),
                bankSlots: 10,
                abilities: [],
                quests: {},
                activeSetBonuses: {},
                tempBuffs: [],
                dialogueInteractions: {},
            };

            for (const questId of Object.keys(quests)) {
                player.quests[questId] = {
                    isAccepted: false,
                    isComplete: false,
                    isTurnedIn: false,
                    progress: 0 // Add any other fields needed for your quest logic
                };
            }
            // Add starting abilities based on class
            for (const [abilityId, abilityData] of Object.entries(abilities)) {
                if (abilityData.class === classId && abilityData.level === 1) {
                    player.abilities.push(abilityId);
                }
            }

            // Add starting weapon based on class
            let startingWeaponId;
            switch (classId) {
                case 'warrior':
                case 'fighter':
                    startingWeaponId = 'rusty_sword';
                    break;
                case 'rogue':
                    startingWeaponId = 'rusty_dagger';
                    break;
                case 'wizard':
                    startingWeaponId = 'bent_staff';
                    break;
            }
            const item = { ...items[startingWeaponId] };
            player.equipment[item.slot] = item;
            for (const [stat, value] of Object.entries(item.stats)) {
                player.stats[stat] += value;
            }

            // Overwrite character data in Firebase
            db.collection('players').doc(currentUser.uid).set(player)
                .then(() => {
                    logMessage(`Welcome, ${player.name}! Your adventure begins anew.`, "text-green-400");
                    characterSelectionScreen.classList.add('hidden');
                    townScreen.classList.remove('hidden');
                    updatePlayerDisplay();
                })
                .catch(error => {
                    logMessage("Error creating character: " + error.message, "text-red-400");
                });
        }

        function enterShop() {
			townScreen.classList.add('hidden');
			shopScreen.classList.remove('hidden');

			const npcData = npcs[player.currentArea]?.vendor;
			if (!npcData) return;

			const dialogueText = getNpcAreaDialogue(npcData);

			document.getElementById('shop-npc-image').src = npcData.image;
			document.getElementById('shop-npc-name').textContent = npcData.name;
			// This is the line that has been changed
			document.getElementById('shop-npc-text').innerHTML = dialogueText;

			populateShop();
			populatePlayerSellList();
			updatePlayerDisplay();
		}

        function exitShop() {
            shopScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
        }

        function enterInn() {
            townScreen.classList.add('hidden');
            innScreen.classList.remove('hidden');
            document.getElementById('inn-main-view').classList.remove('hidden');
            document.getElementById('inn-reputation-view').classList.add('hidden');

            const trainBtn = document.getElementById('inn-train-btn');
            if (player.level < 5) {
                trainBtn.disabled = true;
                addSimpleTooltip(trainBtn, "Requires Level 5");
            } else if (player.subclass) {
                trainBtn.disabled = true;
                 addSimpleTooltip(trainBtn, "You have already chosen a specialization.");
            } else {
                 trainBtn.disabled = false;
            }
        }

        function exitInn() {
            innScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
			updatePlayerDisplay();
        }
        function updateSetBonuses() {
            // 1. First, remove any previously active set bonuses to reset the stats.
            for (const setId in player.activeSetBonuses) {
                const bonus = player.activeSetBonuses[setId];
                for (const stat in bonus.stats) {
                    player.stats[stat] -= bonus.stats[stat];
                }
            }
            player.activeSetBonuses = {}; // Clear the active bonuses

            // 2. Count the number of equipped pieces from each set.
            const equippedSetCounts = {};
            for (const slot in player.equipment) {
                const item = player.equipment[slot];
                if (item && item.set) {
                    equippedSetCounts[item.set] = (equippedSetCounts[item.set] || 0) + 1;
                }
            }

            // 3. Apply new bonuses based on the counts.
            for (const setId in equippedSetCounts) {
                const count = equippedSetCounts[setId];
                const set = setBonuses[setId];
                if (set) {
                    for (const requiredCount in set) {
                        if (count >= requiredCount) {
                            const bonus = set[requiredCount];
                            // Apply the stats
                            for (const stat in bonus.stats) {
                                player.stats[stat] += bonus.stats[stat];
                            }
                            // Store the active bonus
                            player.activeSetBonuses[setId] = bonus;
                            logMessage(`Set Bonus Active: ${bonus.description}`, 'text-purple-400');
                        }
                    }
                }
            }
            // Finally, refresh the UI to show the new stat totals
            updatePlayerDisplay();
        }

        function showSubclassSelection() {
            innScreen.classList.add('hidden');
            subclassSelectionScreen.classList.remove('hidden');
            const container = document.getElementById('subclass-selection-container');
            container.innerHTML = '';

            const availableSubclasses = subclasses[player.classId];
            for (const [subclassId, subclassData] of Object.entries(availableSubclasses)) {
                const card = document.createElement('div');
                card.className = 'class-card bg-gray-700 p-6 rounded-xl text-center cursor-pointer';
                let abilitiesHtml = '<ul class="text-left text-sm mt-4 space-y-1">';
                subclassData.abilities.forEach(abilityId => {
                    const ability = abilities[abilityId];
                    abilitiesHtml += `<li><span class="font-bold text-yellow-400">Lvl ${ability.level}:</span> ${ability.name}</li>`;
                });
                abilitiesHtml += '</ul>';

                card.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">${subclassData.name}</h3>
                    <p class="text-sm text-gray-400">${subclassData.description}</p>
                    ${abilitiesHtml}
                `;
                card.onclick = () => selectSubclass(subclassId);
                container.appendChild(card);
            }
        }

        function selectSubclass(subclassId) {
            if (player.subclass) {
                 logMessage("You have already chosen a path.", "text-yellow-400");
                 return;
            }
            player.subclass = subclassId;
            const subclassName = subclasses[player.classId][subclassId].name;
            logMessage(`You paid 100 gold and have become a ${subclassName}!`, 'text-green-400');
            
            // Re-check for abilities in case player is already >= level 6/8/10
            levelUp(); 

            subclassSelectionScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
            updatePlayerDisplay();
        }

        function showMapScreen() {
            townScreen.classList.add('hidden');
            mapScreen.classList.remove('hidden');
            const mapContainer = document.getElementById('map-container');
            mapContainer.innerHTML = '';

            // --- NEW LOGIC START ---
            const hasMapPiece1 = player.inventory.some(slot => slot.item && slot.item.name === items.map_piece_1.name);
            const hasMapPiece2 = player.inventory.some(slot => slot.item && slot.item.name === items.map_piece_2.name);
            const hasMapPiece3 = player.inventory.some(slot => slot.item && slot.item.name === items.map_piece_3.name);
            const hasMapPiece4 = player.inventory.some(slot => slot.item && slot.item.name === items.map_piece_4.name);
            const hasAllPieces = hasMapPiece1 && hasMapPiece2 && hasMapPiece3 && hasMapPiece4;
            // --- NEW LOGIC END ---

            for (const [areaId, areaData] of Object.entries(areas)) {
                // --- MODIFIED LOGIC ---
                // If the area is the Dragon Wasteland and the player doesn't have the pieces, skip it.
                if (areaId === 'dragon_wasteland' && !hasAllPieces) {
                    continue;
                }
                // --- END MODIFICATION ---

                const areaCard = document.createElement('div');
                areaCard.className = `p-6 rounded-xl cursor-pointer ${areaData.background}`;
                areaCard.innerHTML = `
                    <h3 class="text-2xl font-bold">${areaData.name}</h3>
                    <p>${areaData.description}</p>
                `;
                if (player.currentArea === areaId) {
                    areaCard.innerHTML += `<p class="font-bold text-yellow-400 mt-2">You are here</p>`;
                } else {
                    areaCard.onclick = () => travelToArea(areaId);
                }
                mapContainer.appendChild(areaCard);
            }
        }

        function travelToArea(areaId) {
            const areaData = areas[areaId];

            // Check if the player meets the minimum level requirement
            if (areaData.minLevel && player.level < areaData.minLevel) {
                logMessage(`You must be level ${areaData.minLevel} to enter the ${areaData.name}.`, 'text-red-400');
                return; // Stop the function if the level is too low
            }

            player.currentArea = areaId;
            logMessage(`You have traveled to the ${areas[areaId].name}.`);
            
            mapScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
            document.querySelector('#town-screen h1').textContent = `Welcome to ${areas[areaId].name}`;
            updateBackground(areaId);
        }

        function populateShop() {
            shopInventory = [];
            // Filter items based on player level before picking them
            const availableItemKeys = Object.keys(items).filter(key => {
                const item = items[key];
                // An item is available if:
                // 1. It is purchasable
                // 2. It has NO minLevel, OR the player's level is high enough
                const isPurchasable = item.purchasable !== false;
                const meetsLevelReq = !item.minLevel || player.level >= item.minLevel;
                return isPurchasable && meetsLevelReq;
            });

            // Make sure there are items to show before trying to populate the shop
            if (availableItemKeys.length === 0) {
                console.log("No items available for the player at this level.");
                updateShopDisplay();
                return;
            }

            // Populate the shop with up to 5 items from the available pool
            const numItemsToShow = Math.min(5, availableItemKeys.length);
            for(let i = 0; i < numItemsToShow; i++) {
                const randomKey = availableItemKeys[Math.floor(Math.random() * availableItemKeys.length)];
                shopInventory.push({ ...items[randomKey] });
                // Optional: remove key from availableItemKeys to prevent duplicates in one refresh
            }
            updateShopDisplay();
        }

        function populatePlayerSellList() {
            const sellContainer = document.getElementById('player-sell-inventory');
            sellContainer.innerHTML = '';
            const allItems = player.inventory.map(s => s.item).filter(i => i);
            const itemCounts = player.inventory.reduce((acc, slot) => {
                if (slot.item) {
                    acc[slot.item.name] = (acc[slot.item.name] || 0) + slot.quantity;
                }
                return acc;
            }, {});
             Object.values(player.equipment).forEach(item => {
                if (item) {
                    itemCounts[item.name] = (itemCounts[item.name] || 0) + 1;
                }
            });

            const displayedItems = new Set();

            allItems.forEach((item, index) => {
                if (!item || displayedItems.has(item.name)) return;
                displayedItems.add(item.name);

                const itemEl = document.createElement('div');
                const rarityInfo = rarities[item.rarity];
                const sellPrice = item.value;
                const count = itemCounts[item.name];

                let actionButtons = `<button class="sell-btn bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded" data-item-name="${item.name}">Sell (${sellPrice}g)</button>`;
                if (item.upgradesTo && count >= 3) {
                    const upgradeCost = item.upgradeCost || 0;
                    actionButtons += `<button class="upgrade-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded ml-2" data-item-name="${item.name}">Upgrade (${upgradeCost}g)</button>`;
                }

                itemEl.className = `flex items-center justify-between p-2 rounded-lg ${rarityInfo.color}`;
                let iconHtml = '';
                if (item.icon && item.icon.endsWith('.png')) {
                    iconHtml = `<img src="${item.icon}" alt="${item.name}" class="w-10 h-10 object-contain">`;
                } else {
                    iconHtml = item.icon; // Just the emoji text
                }

                itemEl.className = `flex items-center justify-between p-2 rounded-lg ${rarityInfo.color}`;
                itemEl.innerHTML = `
                    <div class="flex items-center">
                        <div class="slot ${rarityInfo.borderColor} rounded-md flex items-center justify-center mr-4 text-2xl">${iconHtml}</div>
                        <div>
                            <p class="font-bold ${rarityInfo.textColor}">${item.name} (x${count})</p>
                            <p class="text-xs text-gray-400">${Object.entries(item.stats || {}).map(([s, v]) => `+${v} ${s}`).join(', ')}</p>
                        </div>
                    </div>
                    <div>
                        ${actionButtons}
                    </div>
                `;
                sellContainer.appendChild(itemEl);
                addTooltipEvents(itemEl.querySelector('.slot'), item);
            });
             document.querySelectorAll('.sell-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.itemName;
                    sellItem(itemName);
                });
            });
            document.querySelectorAll('.upgrade-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.itemName;
                    upgradeItem(itemName);
                });
            });
        }

        function upgradeItem(itemName) {
            const itemToUpgrade = Object.values(items).find(i => i.name === itemName);
            if (!itemToUpgrade || !itemToUpgrade.upgradesTo) return;

            const upgradeCost = itemToUpgrade.upgradeCost || 0;
            if (player.gold < upgradeCost) {
                logMessage("You don't have enough gold to upgrade this item.", "text-red-400");
                return;
            }

            let count = 0;
            const slotsToRemoveFrom = [];
            player.inventory.forEach((slot, index) => {
                if (slot.item && slot.item.name === itemName) {
                    slotsToRemoveFrom.push(slot);
                }
            });

            if (slotsToRemoveFrom.reduce((sum, s) => sum + s.quantity, 0) < 3) {
                 logMessage("Not enough items to upgrade.", "text-red-400");
                 return;
            }

            player.gold -= upgradeCost;

            let removedCount = 0;
            for (const slot of slotsToRemoveFrom) {
                while(slot.quantity > 0 && removedCount < 3) {
                    slot.quantity--;
                    removedCount++;
                }
                if (slot.quantity === 0) {
                    slot.item = null;
                }
            }

            const upgradedItemKey = itemToUpgrade.upgradesTo;
            const upgradedItem = { ...items[upgradedItemKey] };
            addItemToInventory(upgradedItem);
            
            logMessage(`You paid ${upgradeCost} gold to upgrade 3 ${itemName} into a ${upgradedItem.name}!`, 'text-green-400');
            populatePlayerSellList();
            updatePlayerDisplay();
        }

        function buyItem(index) {
            const item = shopInventory[index];
            const price = item.value * 3;

            if (player.gold < price) {
                logMessage("You don't have enough gold!");
                return;
            }
            
            if (addItemToInventory(item)) {
                player.gold -= price;
                shopInventory.splice(index, 1); // Removes item from the array
                logMessage(`You bought ${item.name} for ${price} gold.`);
                updatePlayerDisplay();
                updateShopDisplay(); // <-- ADD THIS LINE to redraw the shop
                populatePlayerSellList();
            }
        }

        function updateShopDisplay() {
            const shopContainer = document.getElementById('shop-inventory');
            shopContainer.innerHTML = '';
            shopInventory.forEach((item, index) => {
                const itemEl = document.createElement('div');
                const rarityInfo = rarities[item.rarity];
                const buyPrice = item.value * 3;

                // --- Start of new logic ---
                let iconHtml = '';
                if (item.icon && item.icon.endsWith('.png')) {
                    // If it's a PNG, create an <img> tag
                    iconHtml = `<img src="${item.icon}" alt="${item.name}" class="w-10 h-10 object-contain">`;
                } else {
                    // Otherwise, it's an emoji
                    iconHtml = item.icon;
                }
                // --- End of new logic ---

                itemEl.className = `flex items-center justify-between p-2 rounded-lg ${rarityInfo.color}`;
                itemEl.innerHTML = `
                    <div class="flex items-center">
                        <div class="slot ${rarityInfo.borderColor} rounded-md flex items-center justify-center mr-4 text-2xl">${iconHtml}</div>
                        <div>
                            <p class="font-bold ${rarityInfo.textColor}">${item.name}</p>
                            <p class="text-xs text-gray-400">${Object.entries(item.stats || {}).map(([s, v]) => `+${v} ${s}`).join(', ')}</p>
                        </div>
                    </div>
                    <button class="buy-btn bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded" data-index="${index}">Buy (${buyPrice}g)</button>
                `;
                shopContainer.appendChild(itemEl);
                addTooltipEvents(itemEl, item);
            });
            document.querySelectorAll('.buy-btn').forEach(btn => {
                btn.addEventListener('click', (e) => buyItem(parseInt(e.target.dataset.index)));
            });
        }

        function sellItem(itemName) {
            let item;
            
            const inventorySlot = player.inventory.find(slot => slot.item && slot.item.name === itemName);
            if (inventorySlot) {
                item = inventorySlot.item;
                inventorySlot.quantity--;
                if (inventorySlot.quantity <= 0) {
                    inventorySlot.item = null;
                    inventorySlot.quantity = 0;
                }
            } else {
                const equipmentSlotKey = Object.keys(player.equipment).find(slot => player.equipment[slot] && player.equipment[slot].name === itemName);
                if (!equipmentSlotKey) return;
                
                item = player.equipment[equipmentSlotKey];
                for(const [stat, value] of Object.entries(item.stats)) { player.stats[stat] -= value; }
                player.equipment[equipmentSlotKey] = null;
            }

            if (!item) return;
            
            player.gold += item.value;
            logMessage(`You sold ${item.name} for ${item.value} gold.`);
            updatePlayerDisplay();
            populatePlayerSellList();
        }
        
        function updateCombatUI() {
            document.getElementById('dungeon-floor-number').textContent = dungeonFloor;
            document.getElementById('combat-player-name').textContent = player.subclass ? `${player.name} (${subclasses[player.classId][player.subclass].name})` : player.name;
            document.getElementById('combat-player-hp').textContent = player.currentHealth;
            document.getElementById('combat-player-max-hp').textContent = player.stats.Health;
            document.getElementById('combat-player-health-bar').style.width = `${(player.currentHealth / player.stats.Health) * 100}%`;
            
            document.getElementById('combat-player-mana').textContent = player.currentMana;
            document.getElementById('combat-player-max-mana').textContent = player.stats.Mana;
            document.getElementById('combat-player-mana-bar').style.width = `${(player.currentMana / player.stats.Mana) * 100}%`;

            const abilitiesContainer = document.getElementById('combat-abilities-container');
            abilitiesContainer.innerHTML = '';
            player.abilities.forEach(abilityId => {
                const ability = abilities[abilityId];
                const btn = document.createElement('button');
                btn.className = 'ability-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg w-full disabled:bg-gray-500 disabled:cursor-not-allowed';
                btn.textContent = `${ability.name} (${ability.manaCost} Mana)`;
                btn.disabled = player.currentMana < ability.manaCost;
                btn.dataset.abilityId = abilityId;
                btn.onclick = () => combatTurn(() => playerUseAbility(abilityId));
                abilitiesContainer.appendChild(btn);
            });

            document.getElementById('combat-monster-name').textContent = currentMonster.name;
            document.getElementById('combat-monster-hp').textContent = currentMonster.currentHealth;
            document.getElementById('combat-monster-max-hp').textContent = currentMonster.stats.Health;
            document.getElementById('combat-monster-health-bar').style.width = `${(currentMonster.currentHealth / currentMonster.stats.Health) * 100}%`;
        }

        function enterDungeon(monsterId = null) {
            dungeonFloor = 1; 
            townScreen.classList.add('hidden');
            dungeonScreen.classList.remove('hidden');
            document.getElementById('combat-results').classList.add('hidden');
            
            player.tempBuffs.forEach(buff => {
                player.stats[buff.stat] += buff.amount;
            });

            startCombat(monsterId);
        }

        function startCombat(monsterId = null) {
            setCombatButtonsDisabled(false);
            document.getElementById('combat-results').classList.add('hidden');
            let monsterKey;

            if (monsterId) {
                monsterKey = monsterId;
            } else {
                const currentArea = areas[player.currentArea];
                const areaMonsters = currentArea.monsters;
                const availableMonsters = areaMonsters.filter(key => {
                    const monster = monsters[key];
                    return monster.type !== 'boss' && dungeonFloor >= monster.levelRange[0] && dungeonFloor <= monster.levelRange[1];
                });
                if (availableMonsters.length > 0) {
                    monsterKey = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
                } else {
                    monsterKey = areaMonsters[Math.floor(Math.random() * areaMonsters.length)];
                }
            }

            const monsterTemplate = monsters[monsterKey];
            const scalingFactor = 1 + (dungeonFloor - 1) * 0.15;
            const scaledStats = { ...monsterTemplate.stats };
            scaledStats.Health = Math.floor(scaledStats.Health * scalingFactor);
            scaledStats.Attack = Math.floor(scaledStats.Attack * scalingFactor);
            scaledStats.Defense = Math.floor(scaledStats.Defense * scalingFactor);

            currentMonster = {
                ...monsterTemplate,
                id: monsterKey,
                stats: scaledStats,
                currentHealth: scaledStats.Health,
                statusEffects: []
            };

            // --- START: New Bag of Caltrops Logic ---
            const specialItem = player.equipment.special;
            if (specialItem && specialItem.name === 'Bag of Caltrops') {
                if (Math.random() < 0.5) { // 50% chance to work
                    const attackReduction = Math.floor(currentMonster.stats.Attack * 0.25);
                    currentMonster.stats.Attack = Math.max(1, currentMonster.stats.Attack - attackReduction);
                    logMessage(`Your caltrops slow the ${currentMonster.name}, reducing its Attack!`, 'text-red-400');
                }
            }
            // --- END: New Caltrops Logic ---

            document.getElementById('combat-player-image').src = player.image;
            document.getElementById('combat-monster-image').src = currentMonster.image;

            logMessage(`A wild ${currentMonster.name} appears!`, 'text-red-400');
            updateCombatUI();
        }

        function handleStatusEffects(character, characterName) {
            character.statusEffects.slice().forEach(effect => {
                character.currentHealth = Math.max(0, character.currentHealth - effect.damage);
                if (effect.type === 'poison') {
                    logMessage(`${characterName} takes ${effect.damage} damage from poison.`, 'text-green-500');
                } else if (effect.type === 'burn') {
                    logMessage(`${characterName} takes ${effect.damage} damage from burning.`, 'text-orange-500');
                } else if (effect.type === 'stun') {
                    logMessage(`${characterName} is stunned!`, 'text-yellow-500');
                }
                effect.duration--;
            });

            character.statusEffects = character.statusEffects.filter(effect => effect.duration > 0);
            updateCombatUI();
        }
        
        function setCombatButtonsDisabled(isDisabled) {
            attackBtn.disabled = isDisabled;
            runBtn.disabled = isDisabled;
            
            document.querySelectorAll('[data-ability-id]').forEach(btn => {
                if (isDisabled) {
                    btn.disabled = true;
                } else {
                    const abilityId = btn.dataset.abilityId;
                    const ability = abilities[abilityId];
                    btn.disabled = player.currentMana < ability.manaCost;
                }
            });
        }

        function combatTurn(playerAction) {
            playerAction();
            setCombatButtonsDisabled(true); 

            if (currentMonster.currentHealth <= 0) {
                handleVictory();
                return;
            }

            setTimeout(() => {
                handleStatusEffects(currentMonster, currentMonster.name);
                if (currentMonster.currentHealth <= 0) {
                    handleVictory();
                    return;
                }
                
                if (!currentMonster.statusEffects.some(e => e.type === 'stun')) {
                     monsterAttack();
                }

                if (player.currentHealth <= 0) {
                    handleDefeat();
                    return;
                }

                handleStatusEffects(player, player.name);
                if (player.currentHealth <= 0) {
                    handleDefeat();
                } else {
                    setCombatButtonsDisabled(false); 
                }

            }, 1000);
        }

        function attemptRun() {
            const escapeChance = Math.max(0.1, 0.5 * (player.stats.Dexterity / (player.stats.Dexterity + currentMonster.stats.Attack)));
            
            logMessage(`You attempt to flee... (Chance: ${(escapeChance * 100).toFixed(0)}%)`);
            setCombatButtonsDisabled(true);

            setTimeout(() => {
                if (Math.random() < escapeChance) {
                    logMessage("You successfully escaped!", "text-green-400");
                    returnToTown();
                } else {
                    logMessage("You failed to escape!", "text-red-400");
                    setTimeout(() => {
                        monsterAttack();
                        if (player.currentHealth <= 0) {
                            handleDefeat();
                        } else {
                            setCombatButtonsDisabled(false);
                        }
                    }, 1000);
                }
            }, 1000);
        }

        function playerAttack() {
            let damage = Math.max(1, player.stats.Attack - currentMonster.stats.Defense);
            const critRoll = Math.random();
            const totalCritChance = player.stats.CritChance + (player.stats.Dexterity / 200);

            if (critRoll < totalCritChance) {
                damage = Math.floor(damage * player.stats.CritDamage);
                logMessage(`CRITICAL HIT! You attack the ${currentMonster.name} for <span class="font-bold">${damage}</span> damage!`, 'text-yellow-400');
            } else {
                logMessage(`You attack the ${currentMonster.name} for ${damage} damage.`);
            }
            
            currentMonster.currentHealth = Math.max(0, currentMonster.currentHealth - damage);
            updateCombatUI();
        }

        function showCombatInventory() {
            // Toggle visibility between abilities and items
            document.getElementById('combat-abilities-container').classList.add('hidden');
            document.getElementById('combat-items-container').classList.remove('hidden');
            document.getElementById('attack-btn').classList.add('hidden'); // Hide attack button
            document.getElementById('items-btn').textContent = 'Back to Abilities'; // Change button text
            document.getElementById('items-btn').onclick = hideCombatInventory; // Change button function

            const itemsContainer = document.getElementById('combat-items-container');
            itemsContainer.innerHTML = '';

            const consumables = player.inventory.filter(slot => slot.item && slot.item.type === 'consumable');

            if (consumables.length === 0) {
                itemsContainer.innerHTML = '<p class="text-gray-400 text-center">No consumables available.</p>';
                return;
            }

            consumables.forEach((slot, index) => {
                const item = slot.item;
                const btn = document.createElement('button');
                btn.className = 'ability-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg w-full';
                // Find the original index in the main inventory to pass to the use function
                const originalIndex = player.inventory.findIndex(invSlot => invSlot === slot);
                btn.textContent = `${item.name} (x${slot.quantity})`;
                btn.onclick = () => combatTurn(() => useItemInCombat(originalIndex));
                itemsContainer.appendChild(btn);
            });
        }

        function hideCombatInventory() {
            document.getElementById('combat-items-container').classList.add('hidden');
            document.getElementById('combat-abilities-container').classList.remove('hidden');
            document.getElementById('attack-btn').classList.remove('hidden'); // Show attack button
            document.getElementById('items-btn').textContent = 'Items'; // Reset button text
            document.getElementById('items-btn').onclick = showCombatInventory; // Reset button function
        }

        function useItemInCombat(inventoryIndex) {
            const slot = player.inventory[inventoryIndex];
            if (!slot || !slot.item) return; // Exit if slot is empty

            const item = slot.item;

            // Apply the item's effect
            switch(item.effect.type) {
                case 'heal':
                    player.currentHealth = Math.min(player.stats.Health, player.currentHealth + item.effect.amount);
                    logMessage(`You used a ${item.name} and restored ${item.effect.amount} health.`, 'text-green-400');
                    break;
                case 'mana_heal':
                    player.currentMana = Math.min(player.stats.Mana, player.currentMana + item.effect.amount);
                    logMessage(`You used a ${item.name} and restored ${item.effect.amount} mana.`, 'text-blue-400');
                    break;
                // Note: Temp buffs from items are used *before* combat starts, so we don't handle them here.
            }

            // Consume the item
            slot.quantity--;
            if (slot.quantity <= 0) {
                slot.item = null;
                slot.quantity = 0;
            }
            
            // It's a player's turn, so hide the item menu and update the main combat UI
            hideCombatInventory();
            updateCombatUI();
        }

        function playerUseAbility(abilityId) {
            const ability = abilities[abilityId];
            let manaCost = ability.manaCost; // Start with the base mana cost

            // --- START: New Relic of Manaflame Logic ---
            const specialItem = player.equipment.special;
            // Define which abilities are considered "fire spells"
            const fireSpells = ['fireball', 'burn', 'first_blast', 'fire_bomb', 'fire_rage'];

            if (specialItem && specialItem.name === 'Relic of Manaflame' && fireSpells.includes(abilityId)) {
                manaCost = Math.floor(manaCost * 0.9); // 10% mana cost reduction
                logMessage(`Your Relic of Manaflame reduces the mana cost!`, 'text-blue-300');
            }
            // --- END: New Relic Logic ---

            if (player.currentMana < manaCost) { // Check against the potentially reduced cost
                logMessage("Not enough mana!");
                return;
            }
            player.currentMana -= manaCost; // Deduct the final mana cost

            let damage = 0;
            const totalCritChance = player.stats.CritChance + (player.stats.Dexterity / 200);
            const isCrit = Math.random() < totalCritChance;

            switch(abilityId) {
                // --- BASE ABILITIES ---
                case 'power_strike':
                    damage = Math.max(1, Math.floor(player.stats.Attack * 1.5) - currentMonster.stats.Defense);
                    logMessage(`You use Power Strike for ${damage} damage!`);
                    break;
                case 'shield_bash':
                    damage = Math.max(1, player.stats.Attack - currentMonster.stats.Defense);
                    logMessage(`You bash the ${currentMonster.name} with your shield for ${damage} damage, lowering its defense.`);
                    // NOTE: Add debuff logic here in the future
                    break;
                case 'fireball':
                    damage = Math.max(1, player.stats.Intelligence);
                    currentMonster.statusEffects.push({ type: 'burn', duration: 2, damage: Math.floor(player.stats.Intelligence / 2) });
                    logMessage(`You cast Fireball for ${damage} damage and burn the target!`, 'text-orange-500');
                    break;
                case 'frost_nova':
                    damage = Math.floor(player.stats.Intelligence * 0.8);
                     logMessage(`An explosion of ice deals ${damage} damage and lowers the enemy's Attack.`);
                     // NOTE: Add debuff logic here in the future
                    break;
                case 'quick_strike':
                    damage += Math.max(1, player.stats.Attack - currentMonster.stats.Defense);
                     if (Math.random() < (player.stats.Dexterity / 50)) {
                        damage += Math.max(1, player.stats.Attack - currentMonster.stats.Defense);
                        logMessage(`You use Quick Strike for ${damage} total damage over two hits!`);
                    } else {
                         logMessage(`You use Quick Strike for ${damage} damage.`);
                    }
                    break;
                case 'poison_stab':
                    damage = Math.max(1, player.stats.Attack - currentMonster.stats.Defense);
                    currentMonster.statusEffects.push({ type: 'poison', duration: 3, damage: Math.floor(player.stats.Dexterity / 2) });
                    logMessage(`You stab with a poisoned blade for ${damage} damage, poisoning the target.`);
                    break;
                case 'adrenaline_rush':
                    const attackBoost = Math.ceil(player.stats.Attack * 0.25);
                    player.stats.Attack += attackBoost;
                    player.adrenalineBoost += attackBoost; // Track the boost
                    logMessage(`Adrenaline Rush boosts your Attack by ${attackBoost} for this dungeon run!`, 'text-yellow-400');
                    break;
                case 'battle_cry':
                    player.stats.Attack += 5;
                    logMessage(`Your Battle Cry permanently increases your Attack by 5!`, 'text-yellow-400');
                    break;
                case 'daze_enemy':
                case 'rush_enemy':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 2, damage: 0 });
                    logMessage(`You daze the ${currentMonster.name}, stunning them!`, 'text-yellow-500');
                    break;
                case 'backstab_enemy':
                    damage = Math.max(1, (player.stats.Attack * 2) - currentMonster.stats.Defense);
                    logMessage(`You backstab the ${currentMonster.name} for ${damage} damage!`);
                    break;
                case 'second_wind':
                    const healAmount = Math.floor(player.stats.Health * 0.25);
                    player.currentHealth = Math.min(player.stats.Health, player.currentHealth + healAmount);
                    logMessage(`You use Second Wind and heal for ${healAmount} HP!`);
                    break;

                // --- NEW SUBCLASS ABILITIES ---

                // WIZARD - ARCANE
                case 'confuse':
                    logMessage(`You confuse the ${currentMonster.name}, lowering its stats!`, 'text-purple-400');
                    // Note: This would require a temporary debuff system on the monster
                    break;
                case 'teleport_attack':
                    damage = player.stats.Intelligence; // Ignores defense
                    logMessage(`You teleport behind the ${currentMonster.name} for ${damage} pure damage!`);
                    break;
                case 'corrupt':
                    logMessage(`You corrupt the ${currentMonster.name}, making it attack itself!`, 'text-purple-500');
                    // Note: This would require a 'corrupt' status effect handled in the monster's attack turn
                    break;

                // WIZARD - FROST
                case 'frost_bolt':
                    damage = Math.floor(player.stats.Intelligence * 0.5);
                    currentMonster.statusEffects.push({ type: 'stun', duration: 1, damage: 0 });
                    logMessage(`You hit the ${currentMonster.name} with a Frost Bolt for ${damage} damage, stunning it for 1 turn.`);
                    break;
                case 'freeze':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 3, damage: 0 });
                    logMessage(`You freeze the ${currentMonster.name} solid for 3 turns!`);
                    break;
                case 'ultimate_freeze':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 5, damage: 0 });
                    logMessage(`You unleash an Ultimate Freeze, stunning the ${currentMonster.name} for 5 turns!`);
                    break;

                // WIZARD - FIRE
                case 'burn':
                    currentMonster.statusEffects.push({ type: 'burn', duration: 1, damage: Math.floor(player.stats.Intelligence * 0.5) });
                    logMessage(`You burn the ${currentMonster.name}, lowering its defense.`);
                    // Note: This would also require a temporary defense debuff
                    break;
                case 'first_blast':
                     currentMonster.statusEffects.push({ type: 'burn', duration: 2, damage: player.stats.Intelligence });
                     logMessage(`You blast the ${currentMonster.name} with fire, burning it for 2 turns.`);
                    break;
                case 'fire_bomb':
                    damage = Math.floor(player.stats.Attack * 1.5);
                    const bombDamage = Math.floor(currentMonster.stats.Health * 0.1);
                    damage += bombDamage;
                    logMessage(`You throw a Fire Bomb for ${damage} total damage!`);
                    break;

                // WARRIOR - PROTECTION
                case 'intimidate':
                    damage = Math.floor(player.stats.Attack * 0.5);
                    currentMonster.statusEffects.push({ type: 'stun', duration: 1, damage: 0 });
                    logMessage(`You intimidate the ${currentMonster.name} for ${damage} damage, stunning it for 1 turn.`);
                    break;
                case 'grab':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 2, damage: 0 });
                    logMessage(`You grab and stun the ${currentMonster.name} for 2 turns!`);
                    break;
                case 'knock_out':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 3, damage: 0 });
                    logMessage(`You knock out the ${currentMonster.name} for 3 turns!`);
                    break;

                // WARRIOR - FURY
                case 'spit':
                    damage = Math.floor(player.stats.Attack * 1.5);
                    logMessage(`You spit at the ${currentMonster.name} with rage, dealing ${damage} damage!`);
                    break;
                case 'fire_rage':
                    currentMonster.statusEffects.push({ type: 'burn', duration: 2, damage: player.stats.Attack });
                    logMessage(`Your rage ignites, burning the ${currentMonster.name}!`);
                    break;
                case 'cloud_rage':
                    logMessage(`Your rage clouds the ${currentMonster.name}'s mind, lowering its stats!`);
                     // Note: This would require a temporary debuff system on the monster
                    break;

                // WARRIOR - ARMS MASTER
                case 'burning_blade_attack':
                    damage = Math.floor(player.stats.Attack * 1.35);
                    logMessage(`Your burning blade strikes for ${damage} damage!`);
                    break;
                case 'crit_hit':
                    logMessage(`You focus your senses, guaranteeing critical hits for 3 turns!`);
                    // Note: This would require a temporary buff system on the player
                    break;
                case 'boost_stats':
                    logMessage(`You bolster your resolve, boosting all stats for 3 turns!`);
                    // Note: This would require a temporary buff system on the player
                    break;

                // ROGUE - ASSASSIN
                case 'backstab':
                    damage = player.stats.Attack; // Ignores defense
                    logMessage(`You backstab the ${currentMonster.name} for ${damage} pure damage!`);
                    break;
                case 'crit_stab':
                     logMessage(`You find a weak spot, guaranteeing critical hits for 2 turns!`);
                     // Note: This would require a temporary buff system on the player
                    break;
                case 'hurry_up_and_wait':
                    logMessage(`You trick the ${currentMonster.name}, making it attack itself!`);
                    // Note: This would require a 'corrupt' status effect
                    break;

                // ROGUE - SUBTLETY
                case 'percise_attack':
                    damage = Math.floor(player.stats.Attack * 1.35);
                    logMessage(`Your precise attack deals ${damage} damage!`);
                    break;
                case 'ambush':
                    damage = Math.floor(player.stats.Attack * 0.5);
                    currentMonster.statusEffects.push({ type: 'stun', duration: 1, damage: 0 });
                    logMessage(`You ambush the ${currentMonster.name} for ${damage} damage, stunning it for 1 turn.`);
                    break;
                case 'confuse_enemy':
                    logMessage(`You confuse the ${currentMonster.name}, lowering its stats!`);
                    // Note: This would require a temporary debuff system on the monster
                    break;

                // ROGUE - POISON
                case 'stun_poison':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 2, damage: 0 });
                    logMessage(`You use a fast-acting poison to stun the ${currentMonster.name} for 2 turns!`);
                    break;
                case 'acid_poison':
                    currentMonster.statusEffects.push({ type: 'burn', duration: 1, damage: player.stats.Dexterity });
                    logMessage(`You throw acid poison, burning and weakening the ${currentMonster.name}'s defense.`);
                    // Note: This would also require a temporary defense debuff
                    break;
                case 'boost_all_stats':
                     logMessage(`You use a potent elixir, boosting all your stats for 3 turns!`);
                     // Note: This would require a temporary buff system on the player
                    break;

                // FIGHTER - ATTACKER
                case 'intimidate_fighter':
                    damage = Math.floor(player.stats.Attack * 0.5);
                    currentMonster.statusEffects.push({ type: 'stun', duration: 1, damage: 0 });
                    logMessage(`You intimidate the ${currentMonster.name} for ${damage} damage, stunning it for 1 turn.`);
                    break;
                case 'attack_advantage':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 2, damage: 0 });
                    logMessage(`You press your advantage, stunning the ${currentMonster.name} for 2 turns!`);
                    break;
                case 'no_remorse':
                    damage = Math.floor(player.stats.Attack * 2);
                    logMessage(`You attack with no remorse, dealing a massive ${damage} damage!`);
                    break;

                // FIGHTER - DEFENDER
                case 'power_strike_fighter':
                    damage = Math.floor(player.stats.Attack * 1.5);
                    logMessage(`You deliver a powerful strike for ${damage} damage!`);
                    break;
                case 'boost_stats_fighter':
                    logMessage(`You take a defensive stance, boosting all stats for 3 turns!`);
                    // Note: This would require a temporary buff system on the player
                    break;
                case 'skull_bash':
                    currentMonster.statusEffects.push({ type: 'stun', duration: 3, damage: 0 });
                    logMessage(`You bash the ${currentMonster.name}'s skull, stunning it for 3 turns!`);
                    break;

                // FIGHTER - GLADIATOR
                case 'spit_fighter':
                    damage = Math.floor(player.stats.Attack * 1.5);
                    logMessage(`You spit in the ${currentMonster.name}'s eye, dealing ${damage} damage!`);
                    break;
                case 'rally_together':
                    logMessage(`You rally the crowd, boosting all your stats for 3 turns!`);
                    // Note: This would require a temporary buff system on the player
                    break;
                case 'execute':
                    if (Math.random() < 0.5) {
                        damage = currentMonster.currentHealth;
                        logMessage(`EXECUTE! You land a finishing blow!`, 'text-red-500');
                    } else {
                        const selfDamage = Math.floor(player.stats.Health * 0.5);
                        player.currentHealth = Math.max(0, player.currentHealth - selfDamage);
                        logMessage(`Your execute fails! You take ${selfDamage} damage in the attempt!`, 'text-red-400');
                    }
                    break;
            }
            
            if (isCrit && damage > 0) {
                damage = Math.floor(damage * player.stats.CritDamage);
                logMessage(`CRITICAL HIT! Your ability hits for <span class="font-bold">${damage}</span> damage!`, 'text-yellow-400');
            }
            
            currentMonster.currentHealth = Math.max(0, currentMonster.currentHealth - damage);
            updateCombatUI();
        }

        function monsterAttack() {
            if (currentMonster.abilities && currentMonster.abilities.length > 0) {
                for (const ability of currentMonster.abilities) {
                    if (Math.random() < ability.chance) {
                        useMonsterAbility(ability.id);
                        return; 
                    }
                }
            }

            // --- START: New Medallion of Valor Logic ---
            let defenseBonus = 0;
            const specialItem = player.equipment.special;
            if (specialItem && specialItem.name === 'Medallion of Valor') {
                const missingHealthPercent = 1 - (player.currentHealth / player.stats.Health);
                const chunks = Math.floor(missingHealthPercent / 0.25); // How many 25% chunks are missing
                if (chunks > 0) {
                    defenseBonus = chunks * 5;
                    logMessage(`Your Medallion of Valor grants you +${defenseBonus} Defense!`, 'text-green-300');
                }
            }
            // --- END: New Medallion Logic ---

            // Damage is now calculated using the bonus defense
            let damage = Math.max(1, currentMonster.stats.Attack - (player.stats.Defense + defenseBonus));
            
            const critRoll = Math.random();
            if (critRoll < currentMonster.stats.CritChance) {
                damage = Math.floor(damage * currentMonster.stats.CritDamage);
                logMessage(`CRITICAL HIT! The ${currentMonster.name} attacks you for <span class="font-bold">${damage}</span> damage.`, 'text-red-500');
            } else {
                logMessage(`The ${currentMonster.name} attacks you for ${damage} damage.`);
            }
            player.currentHealth = Math.max(0, player.currentHealth - damage);

            // --- Sigil of Retribution Logic (from before) ---
            if (specialItem && specialItem.name === 'Sigil of Retribution' && player.currentHealth > 0) {
                if (Math.random() < 0.15) { 
                    const retaliationDamage = Math.floor(player.stats.Attack * 0.5);
                    currentMonster.currentHealth = Math.max(0, currentMonster.currentHealth - retaliationDamage);
                    logMessage(`Your Sigil of Retribution retaliates for ${retaliationDamage} damage!`, 'text-yellow-400');
                }
            }

            updateCombatUI();
        }

        function useMonsterAbility(abilityId) {
			const ability = monsterAbilities[abilityId];
			logMessage(`The ${currentMonster.name} uses ${ability.name}!`, 'text-yellow-400');
			let healAmount;

			switch(abilityId) {
				case 'rampage':
					let damage = Math.max(1, Math.floor(currentMonster.stats.Attack * 1.5) - player.stats.Defense);
					player.currentHealth = Math.max(0, player.currentHealth - damage);
					break;
				case 'lesser_heal':
					healAmount = 20;
					currentMonster.currentHealth = Math.min(currentMonster.stats.Health, currentMonster.currentHealth + healAmount);
					logMessage(`It heals itself for ${healAmount} health.`);
					break;
				case 'minor_heal':
					healAmount = 10;
					currentMonster.currentHealth = Math.min(currentMonster.stats.Health, currentMonster.currentHealth + healAmount);
					logMessage(`It heals itself for ${healAmount} health.`);
					break;

				// NEW DRAGON ABILITIES
				case 'forest_dragon_breath':
					logMessage(`A cloud of spores envelops you!`, 'text-green-500');
					const poisonDamage = Math.floor(currentMonster.stats.Attack * 0.5);
					player.statusEffects.push({ type: 'poison', duration: 2, damage: poisonDamage });
					break;
				case 'swamp_dragon_venom':
					logMessage(`The venom melts through your armor!`, 'text-purple-500');
					const pureDamage = Math.max(1, currentMonster.stats.Attack * 2); // Deals double damage, ignores defense
					player.currentHealth = Math.max(0, player.currentHealth - pureDamage);
					break;
				case 'scorched_dragon_firestorm':
					logMessage(`You are engulfed in a firestorm!`, 'text-orange-500');
					const fireDamage = Math.floor(currentMonster.stats.Attack * 0.8);
					player.statusEffects.push({ type: 'burn', duration: 3, damage: fireDamage });
					break;
			}
			updateCombatUI();
		}

        function challengeCurrentBoss() {
			showGuideModal('first_boss');
			
            const currentArea = areas[player.currentArea];
            if (!currentArea || !currentArea.boss || currentArea.boss.length === 0) {
                logMessage("There is no boss to challenge in this area.", "text-yellow-400");
                return;
            }

            let bossToSpawn = null;

            // Specific logic for the Forgotten Forest based on quest completion
            if (player.currentArea === 'forgotten_forest') {
                const orcQuestTurnedIn = player.quests.kill_forgotten_forest_boss.isTurnedIn;
                const dragonQuestTurnedIn = player.quests.kill_forgotten_forest_dragon.isTurnedIn;

                if (!orcQuestTurnedIn) {
                    // If the orc quest isn't done, the orc is the only boss.
                    bossToSpawn = 'orc_chieftain';
                } else if (orcQuestTurnedIn && !dragonQuestTurnedIn) {
                    // If the orc quest is done but the dragon isn't, the dragon is the only boss.
                    bossToSpawn = 'forest_dragon';
                } else {
                    // If both are done, pick one randomly from the area's boss list.
                    const availableBosses = currentArea.boss;
                    bossToSpawn = availableBosses[Math.floor(Math.random() * availableBosses.length)];
                }
            } else {
                // For any other area, just pick a random boss from its list.
                if (Array.isArray(currentArea.boss)) {
                    bossToSpawn = currentArea.boss[Math.floor(Math.random() * currentArea.boss.length)];
                } else {
                    bossToSpawn = currentArea.boss;
                }
            }

            if (bossToSpawn) {
                enterDungeon(bossToSpawn);
            }
        }

		function handleVictory() {
            // Show victory message and rewards
            let rewardMessage = '';
            if (currentMonster && currentMonster.xp) {
                player.xp += currentMonster.xp;
                rewardMessage += `You gained ${currentMonster.xp} XP. `;
            }
            if (currentMonster && currentMonster.gold) {
                player.gold += currentMonster.gold;
                rewardMessage += `You found ${currentMonster.gold} gold. `;
            }

            // Monster drops (if any)
            if (currentMonster && currentMonster.drops) {
                currentMonster.drops.forEach(drop => {
                    if (Math.random() < drop.chance) {
                        addItemToInventory({ ...items[drop.itemId] });
                        rewardMessage += `You found ${items[drop.itemId].name}! `;
                    }
                });
            }

            // Faction reward (defensive!)
            if (
                currentMonster &&
                typeof currentMonster.factionId !== 'undefined' &&
                typeof currentMonster.factionReward !== 'undefined'
            ) {
                // Ensure player.factions is initialized
                if (!player.factions) player.factions = {};
                // If the faction is not initialized, set to 0
                if (typeof player.factions[currentMonster.factionId] === 'undefined') {
                    player.factions[currentMonster.factionId] = 0;
                }
                player.factions[currentMonster.factionId] += currentMonster.factionReward;
                rewardMessage += `Reputation gained with ${factions[currentMonster.factionId]?.name || currentMonster.factionId}. `;
            }

            // Quest progress (defensive!)
            if (
                currentMonster &&
                typeof currentMonster.questId !== 'undefined' &&
                player.quests &&
                typeof player.quests[currentMonster.questId] !== 'undefined'
            ) {
                player.quests[currentMonster.questId].progress += 1;
            }

            // Level up if needed
            if (player.xp >= player.xpNeeded) {
                levelUp();
            }

            // Show victory UI elements
            document.getElementById('combat-results').classList.remove('hidden');
            document.getElementById('return-to-town-btn').classList.remove('hidden');

            // Show next floor button only if not a boss
            if (currentMonster && currentMonster.type !== 'boss') {
                document.getElementById('next-floor-btn').classList.remove('hidden');
            } else {
                document.getElementById('next-floor-btn').classList.add('hidden');
            }
            document.getElementById('results-title').textContent = "VICTORY!";
            document.getElementById('results-rewards').textContent = rewardMessage;
        }

        function handleDefeat() {
			logMessage("You have been defeated...");
			player.currentHealth = 1;
			document.getElementById('combat-results').classList.remove('hidden');
			document.getElementById('next-floor-btn').classList.add('hidden');
			document.getElementById('results-title').textContent = "DEFEAT";
			document.getElementById('results-rewards').textContent = `You limp back to town to recover.`;

			// ADD THIS CALL
			showGuideModal('first_death');
		}

        function returnToTown() {
            player.tempBuffs.forEach(buff => {
                player.stats[buff.stat] -= buff.amount;
            });
            player.tempBuffs = [];
            
            if (player.adrenalineBoost > 0) {
                player.stats.Attack -= player.adrenalineBoost;
                player.adrenalineBoost = 0;
            }
            
            dungeonScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
            updateBackground(player.currentArea);
            updatePlayerDisplay();
        }

    
        function restAtInn() {
            const cost = 10;
            if (player.gold < cost) {
                logMessage("You don't have enough gold to rest at the inn.", "text-red-400");
                return;
            }
            if (player.currentHealth === player.stats.Health && player.currentMana === player.stats.Mana) {
                logMessage("You are already fully rested.", "text-yellow-400");
                return;
            }

            player.gold -= cost;
            player.currentHealth = player.stats.Health;
            player.currentMana = player.stats.Mana;
            logMessage(`You pay ${cost} gold and rest at the inn. Your health and mana are fully restored.`, 'text-green-400');
            updatePlayerDisplay();
        }

        function showReputationScreen() {
            document.getElementById('inn-main-view').classList.add('hidden');
            document.getElementById('inn-reputation-view').classList.remove('hidden');

            const npcData = npcs[player.currentArea]?.godsTrainer; // Get the correct trainer
            if (!npcData) return; // Safety check

            const dialogueText = getNpcAreaDialogue(npcData);

            document.getElementById('reputation-npc-image').src = npcData.image;
            document.getElementById('reputation-npc-name').textContent = npcData.name;
            document.getElementById('reputation-npc-text').textContent = dialogueText;

            updateReputationUI();
        }

        function getCurrentReputationTier() {
            let currentTier = reputationTiers[0];
            for (let i = reputationTiers.length - 1; i >= 0; i--) {
                if (player.reputation.points >= reputationTiers[i].required) {
                    currentTier = reputationTiers[i];
                    break;
                }
            }
            return currentTier;
        }

        function getNextReputationTier() {
            const currentTier = getCurrentReputationTier();
            const currentTierIndex = reputationTiers.findIndex(t => t.name === currentTier.name);
            if (currentTierIndex < reputationTiers.length - 1) {
                return reputationTiers[currentTierIndex + 1];
            }
            return null;
        }

        function donateToFaction() {
            if (!player.reputation.factionId) return;
            const cost = 10;
            const repGain = 5;

            if (player.gold < cost) {
                logMessage("You don't have enough gold to donate.", "text-red-400");
                return;
            }

            player.gold -= cost;
            player.reputation.points += repGain;

            logMessage(`You donated ${cost} gold to the ${factions[player.reputation.factionId].name} and gained ${repGain} reputation.`, 'text-yellow-500');

            checkReputationLevelUp();
            updatePlayerDisplay();
            updateReputationUI();
        }

        function updateReputationUI() {
            const factionContainer = document.getElementById('faction-container');
            factionContainer.innerHTML = '';

            Object.entries(factions).forEach(([id, faction]) => {
                const isCurrentFaction = player.reputation.factionId === id;
                const factionEl = document.createElement('div');
                factionEl.className = `bg-gray-800 p-4 rounded-lg ${isCurrentFaction ? 'border-2 border-yellow-400' : ''}`;
                
                let html = `<h3 class="text-xl font-bold">${faction.name}</h3>`;
                
                if (isCurrentFaction) {
                    const currentTier = getCurrentReputationTier();
                    const nextTier = getNextReputationTier();
                    html += `<p class="text-lg">Standing: <span class="font-semibold text-yellow-400">${currentTier.name}</span></p>`;
                    if (nextTier) {
                        const pointsIntoTier = player.reputation.points - currentTier.required;
                        const pointsForNextTier = nextTier.required - currentTier.required;
                        const progressPercent = (pointsIntoTier / pointsForNextTier) * 100;
                        html += `
                            <div class="w-full health-bar-bg rounded-full h-4 mt-2 border-2 border-gray-600">
                                <div class="reputation-bar-fill h-full rounded-full" style="width: ${progressPercent}%"></div>
                            </div>
                            <p class="text-xs text-center mt-1">Reputation: ${player.reputation.points} / ${nextTier.required}</p>
                            <button id="donate-faction-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded mt-2">Donate 10g for 5 Rep</button>
                        `;
                    } else {
                         html += `<p class="text-green-400 font-bold">You have reached the maximum reputation!</p>`;
                    }
                } else {
                    html += `<button class="join-faction-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded mt-2" data-faction-id="${id}">Join Faction</button>`;
                }
                factionEl.innerHTML = html;
                factionContainer.appendChild(factionEl);
            });

            document.querySelectorAll('.join-faction-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const newFactionId = e.target.dataset.factionId;
                    if (player.reputation.factionId && player.reputation.factionId !== newFactionId) {
                        const oldFaction = factions[player.reputation.factionId];
                        player.stats[oldFaction.neutralStatBonus.stat] -= oldFaction.neutralStatBonus.value;
                        player.abilities = player.abilities.filter(id => id !== oldFaction.reveredAbilityId);
                        logMessage(`You have abandoned the ${oldFaction.name}. Your reputation and bonuses have been reset.`, 'text-red-400');
                        player.reputation.points = 0;
                        player.reputation.claimedRewards = [];
                    }
                    player.reputation.factionId = newFactionId;
                    const newFaction = factions[newFactionId];
                    player.stats[newFaction.neutralStatBonus.stat] += newFaction.neutralStatBonus.value;
                    logMessage(`You have pledged allegiance to the ${newFaction.name} and gained +1 ${newFaction.neutralStatBonus.stat}.`, 'text-green-400');
                    updatePlayerDisplay();
                    updateReputationUI();
                };
            });

            const donateBtn = document.getElementById('donate-faction-btn');
            if(donateBtn) {
                donateBtn.onclick = donateToFaction;
            }

            updateReputationRewardUI();
        }
        
        function updateReputationRewardUI() {
            const rewardContainer = document.getElementById('reputation-reward-container');
            rewardContainer.innerHTML = '';
            if (!player.reputation.factionId) return;

            const currentTier = getCurrentReputationTier();
            const faction = factions[player.reputation.factionId];

            if (currentTier.name === 'Legacy' && !player.reputation.claimedRewards.includes(faction.rewardItemId)) {
                const rewardBtn = document.createElement('button');
                rewardBtn.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg';
                rewardBtn.textContent = `Claim ${items[faction.rewardItemId].name}`;
                rewardBtn.onclick = () => {
                    if (addItemToInventory({ ...items[faction.rewardItemId] })) {
                        player.reputation.claimedRewards.push(faction.rewardItemId);
                        logMessage(`You have claimed your reward: ${items[faction.rewardItemId].name}!`, 'text-purple-400');
                        updateReputationRewardUI();
                    }
                };
                rewardContainer.appendChild(rewardBtn);
            }
        }

        function checkReputationLevelUp() {
            if (!player.reputation.factionId) return;
            const currentTier = getCurrentReputationTier();
            const faction = factions[player.reputation.factionId];

            if (currentTier.name === 'Revered' && !player.abilities.includes(faction.reveredAbilityId)) {
                player.abilities.push(faction.reveredAbilityId);
                logMessage(`Your status with the ${faction.name} has grown! You learned a new ability: ${abilities[faction.reveredAbilityId].name}!`, 'text-purple-400');
            }

            if (currentTier.name === 'Legacy' && player.name !== faction.legacyTitle) {
                player.name = faction.legacyTitle;
                logMessage(`Your deeds are legendary! You are now known as a ${faction.legacyTitle}!`, 'text-purple-500');
                updatePlayerDisplay();
            }
        }

        function showQuestBoard() {
            innScreen.classList.add('hidden');
            questBoardScreen.classList.remove('hidden');

            const npcData = npcs[player.currentArea]?.questGiver; // Get the correct quest giver
            if (!npcData) return; // Safety check

            const dialogueText = getNpcAreaDialogue(npcData);

            document.getElementById('quest-npc-image').src = npcData.image;
            document.getElementById('quest-npc-name').textContent = npcData.name;
            document.getElementById('quest-npc-text').textContent = dialogueText;

            updateQuestBoardUI();
        }

        
        function updateQuestBoardUI() {
            const questBoardContainer = document.getElementById('quest-board-container');
            if (!questBoardContainer) return; // Guard clause for container
            
            questBoardContainer.innerHTML = ''; // Clear previous quest cards

            // Guard clause for player and quests
            if (!player || !player.quests) {
                console.error('Player or player quests not initialized');
                return;
            }

            // Loop through all quests and render them for the player
            for (const [questId, questData] of Object.entries(quests)) {
                // Defensive: Always provide a fallback if quest not initialized
                const playerQuest = (player.quests[questId]) ? player.quests[questId] : {
                    isAccepted: false,
                    isComplete: false,
                    isTurnedIn: false,
                    progress: 0
                };

                // Initialize quest in player data if it doesn't exist
                if (!player.quests[questId]) {
                    player.quests[questId] = { ...playerQuest };
                }

                // Determine quest status and available actions
                let statusText = '';
                let actions = [];

                if (playerQuest.isTurnedIn) {
                    statusText = '<span class="text-green-400">Completed</span>';
                } else if (playerQuest.isComplete) {
                    statusText = '<span class="text-yellow-400">Ready to turn in!</span>';
                    actions.push({
                        label: 'Turn In',
                        callback: () => turnInQuest(questId)
                    });
                } else if (playerQuest.isAccepted) {
                    statusText = `<span class="text-blue-400">In Progress (${playerQuest.progress}/${questData.goal || 1})</span>`;
                } else {
                    statusText = '<span class="text-gray-400">Not Started</span>';
                    actions.push({
                        label: 'Accept',
                        callback: () => acceptQuest(questId)
                    });
                }

                // Create the quest card UI
                const card = document.createElement('div');
                card.className = 'quest-card bg-gray-800 p-4 rounded-lg mb-4 shadow-lg';

                // Create the HTML structure with proper classes and containers
                card.innerHTML = `
                    <h3 class="text-lg font-bold mb-2">${questData.name || questId}</h3>
                    <p class="text-sm mb-2">${questData.description || ''}</p>
                    <div class="mb-2">${statusText}</div>
                    <div class="flex space-x-2"></div>
                `;

                // Add action buttons
                const actionsContainer = card.querySelector('div.flex');
                if (actionsContainer) {  // Make sure we found the container
                    actions.forEach(action => {
                        const btn = document.createElement('button');
                        btn.className = 'bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded';
                        btn.textContent = action.label;
                        btn.onclick = () => {
                            action.callback();
                            updateQuestBoardUI(); // Refresh UI after action
                        };
                        actionsContainer.appendChild(btn);
                    });
                }

                questBoardContainer.appendChild(card);
            }
        }
                
        function acceptQuest(questId) {
            if (player.quests[questId].isAccepted) return;
            player.quests[questId].isAccepted = true;
            logMessage(`Quest accepted: ${quests[questId].title}`, 'text-blue-400');
            updateQuestBoardUI();
        }

		function updateQuestProgress(monsterId, itemId = null) {
			for (const questId in player.quests) {
				const pQuest = player.quests[questId];
				const questDef = quests[questId];
				if (!pQuest.isAccepted || pQuest.isComplete || !questDef) continue;

				let shouldCheck = false;

				if (monsterId) {
					if (questDef.type === 'kill_any') {
						pQuest.progress++;
						shouldCheck = true;
					} else if (questDef.type === 'kill_specific' && questDef.targets[monsterId]) {
						pQuest.progress[monsterId]++;
						shouldCheck = true;
					} else if (questDef.type === 'kill_boss' && questDef.target === monsterId) {
						pQuest.progress = 1;
						shouldCheck = true;
					}
				}

				if (itemId && questDef.type === 'gather_quest_items') {
					// Check if the dropped item is relevant to this quest
					if (questDef.targets.some(t => t.itemId === itemId)) {
						shouldCheck = true;
					}
				}
				
				if (shouldCheck) {
					checkQuestCompletion(questId);
				}
			}
		}

		function checkQuestCompletion(questId) {
			const pQuest = player.quests[questId];
			const questDef = quests[questId];
			if (pQuest.isComplete || !questDef) return;

			let completed = false;
			if (questDef.type === 'kill_any' && pQuest.progress >= questDef.target) {
				completed = true;
			} else if (questDef.type === 'kill_specific') {
				completed = Object.keys(questDef.targets).every(monsterId => pQuest.progress[monsterId] >= questDef.targets[monsterId]);
			} else if (questDef.type === 'kill_boss' && pQuest.progress > 0) {
				completed = true;
			} else if (questDef.type === 'gather_quest_items') {
				// This logic assumes all targets drop the SAME item and we need the SAME quantity.
				// For quests with different items, this would need to be more complex.
				const targetItemInfo = questDef.targets[0];
				const requiredItemId = targetItemInfo.itemId;
				const requiredQuantity = targetItemInfo.quantity;

				const countInInventory = player.inventory.reduce((acc, slot) => {
					if (slot.item && slot.item.name === items[requiredItemId].name) {
						return acc + slot.quantity;
					}
					return acc;
				}, 0);

				if (countInInventory >= requiredQuantity) {
					completed = true;
				}
			}

			if (completed) {
				pQuest.isComplete = true;
				logMessage(`Quest objective complete: ${questDef.title}! Return to the quest board to turn it in.`, 'text-green-400');
			}
		}

		function turnInQuest(questId) {
            const pQuest = player.quests[questId];
            const questDef = quests[questId];

            if (!pQuest.isComplete || pQuest.isTurnedIn) return;

            // --- GATHER QUEST ITEM REMOVAL ---
            if (questDef.type === 'gather_quest_items') {
                // This logic correctly handles quests that require specific items to be gathered.
                const targetItemInfo = questDef.targets[0];
                const requiredItemId = targetItemInfo.itemId;
                let requiredQuantity = targetItemInfo.quantity;

                for (const slot of player.inventory) {
                    if (requiredQuantity > 0 && slot.item && slot.item.name === items[requiredItemId].name) {
                        const amountToRemove = Math.min(requiredQuantity, slot.quantity);
                        slot.quantity -= amountToRemove;
                        requiredQuantity -= amountToRemove;
                        if (slot.quantity <= 0) {
                            slot.item = null;
                        }
                    }
                }
            }

            // --- SPECIAL ITEM REMOVAL (e.g., used keys) ---
            let keyItemIdToRemove = null;

            switch (questId) {
                case 'kill_forgotten_forest_dragon':
                    keyItemIdToRemove = 'ff_dragon_key';
                    break;
                case 'kill_sunken_swamp_dragon':
                    keyItemIdToRemove = 'ss_dragon_key';
                    break;
                case 'kill_scorched_plains_dragon':
                    keyItemIdToRemove = 'sp_dragon_key';
                    break;
                case 'kill_frozen_peak_dragon':
                    keyItemIdToRemove = 'fp_dragon_key';
                    break;
            }

            if (keyItemIdToRemove) {
                const keyNameToRemove = items[keyItemIdToRemove].name;
                for (const slot of player.inventory) {
                    if (slot.item && slot.item.name === keyNameToRemove) {
                        slot.quantity--;
                        if (slot.quantity <= 0) {
                            slot.item = null;
                        }
                        logMessage(`The ${keyNameToRemove} has served its purpose and crumbles to dust.`);
                        break; // Exit the loop once the key is found and removed
                    }
                }
            }

            // --- GRANT REWARDS ---
            player.xp += questDef.reward.xp;
            player.gold += questDef.reward.gold;
            pQuest.isTurnedIn = true;
            
            let rewardLog = `You received ${questDef.reward.xp} XP and ${questDef.reward.gold} Gold.`;
            
            // Grant item reward if it exists
            if (questDef.reward.item) {
                addItemToInventory({ ...items[questDef.reward.item] });
                rewardLog += ` You also received a ${items[questDef.reward.item].name}!`;
            }

            // Grant recipe reward if it exists
            if (questDef.reward.recipe && !player.recipes.includes(questDef.reward.recipe)) {
                const recipeId = questDef.reward.recipe;
                player.recipes.push(recipeId);
                // We log this separately for emphasis
                logMessage(`You learned a new recipe: ${recipes[recipeId].name}!`, 'text-purple-400');
            }

            logMessage(`Quest turned in: ${questDef.title}! ${rewardLog}`, 'text-yellow-400');
            
            // --- UPDATE GAME STATE AND UI ---
            levelUp();
            updatePlayerDisplay();
            updateQuestBoardUI();

            // --- ACHIEVEMENT COMPLETION CHECK ---
            const questArea = questDef.area;
            if (questArea) {
                const allAreaQuests = Object.keys(quests).filter(id => quests[id].area === questArea);
                const allComplete = allAreaQuests.every(id => player.quests[id] && player.quests[id].isTurnedIn);

                if (allComplete) {
                    Object.keys(achievements).forEach(id => {
                        const achievement = achievements[id];
                        if (achievement.area && achievement.area === questArea) {
                            unlockAchievement(id);
                        }
                    });
                }
            }
            if (questDef.reward.unlocks === 'subclass') {
                logMessage("Your trial is complete! You may now choose your specialization.", "text-purple-400");
                questBoardScreen.classList.add('hidden'); // Close the quest board
                showSubclassSelection(); // Open the subclass selection screen
            }
        }

        function showProfessionsScreen() {
            townScreen.classList.add('hidden');
            professionsScreen.classList.remove('hidden');
        }

        let currentProfession = ''; // Store the currently viewed profession

        function showTrainerScreen(profession) {
            townScreen.classList.add('hidden');
            document.getElementById('trainer-screen').classList.remove('hidden');
            currentProfession = profession;

            // Set title
            const title = profession.charAt(0).toUpperCase() + profession.slice(1);
            document.getElementById('trainer-title').textContent = `${title} Trainer`;

            // Populate quests (you can expand this to use your existing quest UI logic)
            const questsContainer = document.getElementById('trainer-quests');
            questsContainer.innerHTML = '<p class="text-gray-400">No quests available.</p>'; // Placeholder

            // Populate recipes
            const recipesContainer = document.getElementById('trainer-recipes');
            recipesContainer.innerHTML = '';
            
            const knownRecipes = player.recipes.filter(id => recipes[id].profession === profession);

            if (knownRecipes.length === 0) {
                recipesContainer.innerHTML = '<p class="text-gray-400">You have not learned any recipes from this profession.</p>';
                return;
            }

            knownRecipes.forEach(recipeId => {
                const recipe = recipes[recipeId];
                const canCraft = canPlayerCraft(recipeId);
                let materialsHtml = '<ul class="text-xs text-gray-400 list-disc list-inside">';
                for (const matId in recipe.materials) {
                    const required = recipe.materials[matId];
                    const owned = countItemInInventory(matId);
                    const color = owned >= required ? 'text-green-400' : 'text-red-400';
                    materialsHtml += `<li class="${color}">${items[matId].name}: ${owned} / ${required}</li>`;
                }
                materialsHtml += '</ul>';

                const recipeEl = document.createElement('div');
                recipeEl.className = 'bg-gray-800 p-3 rounded-lg flex justify-between items-center';
                recipeEl.innerHTML = `
                    <div>
                        <p class="font-bold">${recipe.name}</p>
                        ${materialsHtml}
                    </div>
                    <button class="craft-btn bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded disabled:bg-gray-500" data-recipe-id="${recipeId}" ${!canCraft ? 'disabled' : ''}>
                        Craft
                    </button>
                `;
                recipesContainer.appendChild(recipeEl);
            });

            // Add event listeners to the new craft buttons
            document.querySelectorAll('.craft-btn').forEach(btn => {
                btn.onclick = (e) => craftItem(e.target.dataset.recipeId);
            });
        }

        function countItemInInventory(itemId) {
            return player.inventory.reduce((acc, slot) => {
                if (slot.item && slot.item.name === items[itemId].name) {
                    return acc + slot.quantity;
                }
                return acc;
            }, 0);
        }

        // Helper function to determine if a recipe can be crafted
        function canPlayerCraft(recipeId) {
            const recipe = recipes[recipeId];
            return Object.keys(recipe.materials).every(matId => {
                return countItemInInventory(matId) >= recipe.materials[matId];
            });
        }

        // Helper function to remove items (important for stackables)
        function removeItemsFromInventory(itemId, quantity) {
            let remainingToRemove = quantity;
            for (const slot of player.inventory) {
                if (remainingToRemove > 0 && slot.item && slot.item.name === items[itemId].name) {
                    const amountToRemove = Math.min(remainingToRemove, slot.quantity);
                    slot.quantity -= amountToRemove;
                    remainingToRemove -= amountToRemove;
                    if (slot.quantity <= 0) {
                        slot.item = null;
                    }
                }
            }
        }

        // The main crafting function
        function craftItem(recipeId) {
            if (!canPlayerCraft(recipeId)) {
                logMessage("You don't have the required materials.", "text-red-400");
                return;
            }

            const recipe = recipes[recipeId];

            // Remove materials from inventory
            for (const matId in recipe.materials) {
                removeItemsFromInventory(matId, recipe.materials[matId]);
            }

            // Add crafted item to inventory
            const craftedItem = { ...items[recipe.itemId] };
            addItemToInventory(craftedItem);

            logMessage(`You successfully crafted a ${craftedItem.name}!`, 'text-green-400');
            
            // Refresh the UI to show updated material counts
            showTrainerScreen(currentProfession);
            updatePlayerDisplay(); // Also update main inventory display
        }

        function saveGame() {
			if (!player || !currentUser) {
				logMessage("No game to save.", "text-yellow-400");
				return;
			}
			db.collection('players').doc(currentUser.uid).set(player)
				.then(() => {
					logMessage("Game Saved to Cloud!", "text-green-400");
				})
				.catch(error => {
					logMessage("Error saving game: " + error.message, "text-red-400");
				});
		}

        function loadGame() {
                if (!currentUser) return;

                db.collection('players').doc(currentUser.uid).get()
                    .then(doc => {
                        if (doc.exists) {
                            // --- EXISTING PLAYER ---
                            player = doc.data();

                            // Compatibility checks for older save files
                            if (!player.bank) { 
                                player.bank = new Array(10).fill(null).map(() => ({ item: null, quantity: 0 })); 
                                player.bankSlots = 10; 
                            }
                            if (!player.seenGuideMessages) { 
                                player.seenGuideMessages = []; 
                            }
                            
                            logMessage("Game Loaded from Cloud!", "text-green-400");

                            // Update UI for existing player
                            authScreen.classList.add('hidden');
                            characterSelectionScreen.classList.add('hidden');
                            townScreen.classList.remove('hidden');
                            updateSetBonuses();
                            updateBackground(player.currentArea);
                            updatePlayerDisplay();
                        } else {
                            // --- NEW PLAYER ---
                            logMessage("No character found. Please create a new hero.", "text-yellow-400");

                            // Update UI for new player
                            authScreen.classList.add('hidden');
                            characterSelectionScreen.classList.remove('hidden');
                            initializeClassSelection(); // This populates the screen with choices
                        }
                    })
                    .catch(error => {
                        logMessage("Error loading game: " + error.message, "text-red-400");
                    });
        }

        // --- INITIALIZATION ---
		
        const visitMapBtn = document.getElementById('visit-map');
        const returnToTownFromMapBtn = document.getElementById('return-to-town-from-map');
        const viewAchievementsBtn = document.getElementById('view-achievements');
        const returnToTownFromAchievementsBtn = document.getElementById('return-to-town-from-achievements');
        const professionsScreen = document.getElementById('professions-screen');
        const visitProfessionsBtn = document.getElementById('visit-professions');
        const selectBlacksmithingBtn = document.getElementById('select-blacksmithing');// BlackSmith Prof Select Btn
        const selectHerbalismBtn = document.getElementById('select-herbalism');// Herbalism Prof Select Btn
        const selectCookingBtn = document.getElementById('select-cooking'); // Cooking Prof Select Btn
        const returnToTownFromProfessionsBtn = document.getElementById('return-to-town-from-professions');

        visitProfessionsBtn.addEventListener('click', showProfessionsScreen);
		visitBankBtn.addEventListener('click', enterBank);
		leaveBankBtn.addEventListener('click', exitBank);
		buyBankSlotBtn.addEventListener('click', buyBankSlot);

        selectBlacksmithingBtn.addEventListener('click', () => {
            professionsScreen.classList.add('hidden');
            showTrainerScreen('blacksmithing');
        });

        selectHerbalismBtn.addEventListener('click', () => {
            professionsScreen.classList.add('hidden');
            showTrainerScreen('herbalism');
        });

        selectCookingBtn.addEventListener('click', () => {
            professionsScreen.classList.add('hidden');
            showTrainerScreen('cooking');
        });

        returnToTownFromProfessionsBtn.addEventListener('click', () => {
            professionsScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
        });

        // MODIFY the leave-trainer-btn listener to go back to the professions screen
        const leaveTrainerBtn = document.getElementById('leave-trainer-btn');
        leaveTrainerBtn.addEventListener('click', () => {
            document.getElementById('trainer-screen').classList.add('hidden');
            professionsScreen.classList.remove('hidden'); // <-- Changed from townScreen
        });

        enterDungeonBtn.addEventListener('click', () => enterDungeon());
        challengeBossBtn.addEventListener('click', challengeCurrentBoss);
        attackBtn.addEventListener('click', () => combatTurn(playerAttack));
        itemsBtn.onclick = showCombatInventory;
        runBtn.addEventListener('click', attemptRun);
        returnToTownBtn.addEventListener('click', returnToTown);

        nextFloorBtn.addEventListener('click', () => {
            dungeonFloor++;
            // Check for dungeon floor achievements
            Object.keys(achievements).forEach(id => {
                const achievement = achievements[id];
                if (achievement.type === 'dungeon' && dungeonFloor >= achievement.value) {
                    unlockAchievement(id);
                }
            });
            logMessage(`You proceed to Floor ${dungeonFloor}...`, 'text-yellow-400');
            startCombat();
        });

        visitblacksmithshopBtn.addEventListener('click', () => {
            const currentVendor = npcs[player.currentArea]?.vendor;
            if (!currentVendor) {
                logMessage("There is no vendor in this area.", "text-yellow-400");
                return;
            }

            if (!player.dialogueInteractions) player.dialogueInteractions = {};

            if (player.dialogueInteractions[currentVendor.name] === undefined) {
                showDialogueModal(currentVendor, [
                    { label: 'Trade', callback: enterShop }
                ]);
            } else {
                enterShop();
            }
        });
        leaveShopBtn.addEventListener('click', exitShop);
        visitInnBtn.addEventListener('click', enterInn);
        leaveInnBtn.addEventListener('click', exitInn);
        visitMapBtn.addEventListener('click', showMapScreen);
        returnToTownFromMapBtn.addEventListener('click', () => {
            mapScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
        });
        viewAchievementsBtn.addEventListener('click', showAchievementsScreen);
        returnToTownFromAchievementsBtn.addEventListener('click', () => {
            achievementScreen.classList.add('hidden');
            townScreen.classList.remove('hidden');
        });
        innRestBtn.addEventListener('click', restAtInn);
        innReputationBtn.addEventListener('click', () => {
            const currentGodsTrainer = npcs[player.currentArea]?.godsTrainer;
            if (!currentGodsTrainer) return; // Fail silently if no trainer

            if (!player.dialogueInteractions) player.dialogueInteractions = {};

            if (player.dialogueInteractions[currentGodsTrainer.name] === undefined) {
                showDialogueModal(currentGodsTrainer, [
                    { label: 'View Factions', callback: showReputationScreen }
                ]);
            } else {
                showReputationScreen();
            }
        });
        innTrainBtn.addEventListener('click', handleClassTrainerInteraction);
        innQuestBtn.addEventListener('click', () => {
            const currentQuestGiver = npcs[player.currentArea]?.questGiver;
            if (!currentQuestGiver) return; // Fail silently if no quest giver

            if (!player.dialogueInteractions) player.dialogueInteractions = {};

            // This logic is crucial: It checks if you've seen the intro dialogue yet.
            if (player.dialogueInteractions[currentQuestGiver.name] === undefined) {
                showDialogueModal(currentQuestGiver, [
                    { label: 'View Board', callback: showQuestBoard }
                ]);
            } else {
                showQuestBoard();
            }
        });
        returnToInnBtn.addEventListener('click', () => {
            subclassSelectionScreen.classList.add('hidden');
            innScreen.classList.remove('hidden');
        });
        questReturnToInnBtn.addEventListener('click', () => {
            questBoardScreen.classList.add('hidden');
            innScreen.classList.remove('hidden');
        });
        
		loginBtn.addEventListener('click', handleLogin);
		signupBtn.addEventListener('click', handleSignUp);
		saveGameBtn.addEventListener('click', saveGame);
		guideCloseBtn.addEventListener('click', hideGuideModal);
		document.getElementById('alpha-submit-btn').addEventListener('click', checkAlphaCode);

        function initializeGame() {
            auth.onAuthStateChanged(user => {
                if (user) {
                    // User is signed in.
                    currentUser = user;
                    mainMenuBtn.textContent = 'Logout';
                    mainMenuBtn.onclick = handleLogout;

                    // Always show the class selection screen, even if character exists.
                    characterSelectionScreen.classList.remove('hidden');
                    townScreen.classList.add('hidden');
                    authScreen.classList.add('hidden');
                    alphaGateScreen.classList.add('hidden');
                    initializeClassSelection();
                } else {
                    // User is signed out.
                    currentUser = null;
                    player = null;
                    mainMenuBtn.textContent = 'Main Menu';
                    mainMenuBtn.onclick = () => window.location.reload();

                    // Hide all game screens and show the initial alpha gate screen
                    characterSelectionScreen.classList.add('hidden');
                    townScreen.classList.add('hidden');
                    authScreen.classList.add('hidden');
                    alphaGateScreen.classList.remove('hidden');
                }
            });
        }

        window.onload = initializeGame;
    </script>
</body>
</html>
